<!DOCTYPE html>
<html>
  <head>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  ES6 &ndash; Learning Records

    </title>
    
    <meta content="JavaScript" name="keywords">
    
    
    <meta name="description" property="og:description" content="The article contains the knowledge of ES6&amp;hellip;
|Just for record">
    

    <meta name="apple-mobile-web-app-title" content="Learning Records">
    
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    <meta name="twitter:title" content="ES6 | Learning Records">
    <meta name="twitter:description" content="The article contains the knowledge of ES6&hellip;|Just for record">
    <meta name="twitter:image" content="https://pippichi.github.iotwitter-card.png">
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="stylesheet" href="/assets/custom_style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://pippichi.github.io">
    Learning Records
  </a>

  
  
  <div class="UnderlineNav-body">
    
    
    
    <a class="UnderlineNav-item" href="/blog/">
      
      <span>Home</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item" href="/">
      
      <span>PDF file</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item" href="/about/">
      
      <span>About</span>
    </a>
    
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">ES6</div>
  </div>
  <div class="Subhead-description">
    


<a href='/categories/senior' class="muted-link">
  <span class="Label Label--gray-darker">Senior</span>
</a>



<a href='/tags/javascript' class="muted-link">
  <span class="Label Label--gray">JavaScript</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2020-02-29. Published at: 2020-02-29.">
        
          Published: 2020-02-29
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <p>The article contains the knowledge of ES6&hellip;</p>
<h2 id="es6">ES6</h2>
<p><img src="/ES6/1651d5344b2453ba75e65706a33fbb23.png" alt=""></p>
<p><img src="/ES6/75358553b77833c0a5497fe660de6581.png" alt=""></p>
<h3 id="let">let</h3>
<p><img src="/ES6/4c9d63e6872602b8268db80e30826373.png" alt=""></p>
<h4 id="let与var">let与var</h4>
<p>注意，之前说的闭包里面的某个函数作用域中某个var声明的局部变量在另一个函数作用域中无法使用注意这里是函数作用域不是块级作用域，在块级作用域中var声明的变量在不同块之间是可以访问到的</p>
<p><img src="/ES6/bb9f421f7bc83ff3110757709f5918dd.png" alt=""></p>
<p>比方说这个案例，abc是可以输出的，但是num不行</p>
<h4 id="let能防止for循环中的变量变成全局变量">let能防止for循环中的变量变成全局变量</h4>
<p><img src="/ES6/7198bff448fde7701ad5c93d2fe01b2a.png" alt=""></p>
<p>这里的i能输出，且为2</p>
<p><img src="/ES6/bcd62380ca452a81dfeb207a5d6f39b0.png" alt=""></p>
<p>这里的i不能输出</p>
<h4 id="let不存在变量提升">let不存在变量提升</h4>
<p><img src="/ES6/783b2986d277cf0c08e7a5d264b053e1.png" alt=""></p>
<h4 id="let声明的变量具有暂时性死区的特性">let声明的变量具有暂时性死区的特性</h4>
<p><img src="/ES6/ac381f14dc5335d477b3f6bc4647eb78.png" alt=""></p>
<p>在块级作用域内声明的变量会跟块绑定起来，使其不受外部影响，所以就算外部已经用var声明了这个变量，在块内我们使用let再次声明这个变量，此时块内会以let声明的变量为准，在块内声明的该变量与块外声明的该变量是没有任何关系的，因此上图输出为not
defined</p>
<h4 id="典型案例">典型案例</h4>
<p>1.</p>
<p><img src="/ES6/85c2e3730a528ba880c5236132c089f1.png" alt=""></p>
<p>上图由于循环的时候函数arr<a href="">i</a>并没有执行，arr<a href="">i</a>这个函数是在循环结束之后再执行的，并且在函数内部并没有定义i，所以函数执行时在自己的作用域内是找不到变量i值的，根据作用域链原则要向上一层作用域去找i，实际上上层作用域就是全局作用域，而在全局作用域下是有变量i的，实际上就是循环时创建的全局变量i，由于arr<a href="">0</a>，arr<a href="">1</a>这两个函数执行的时候循环早就结束了，因此这两个函数用到的都是全局变量i，而且输出的i值为2，且两个函数都是输出2。（这里其实可以这样想：两个函数输出的都是全局变量i，且两个函数都要到循环结束之后再执行，而i到最后跳出循环的时候就是2，所以两个函数输出的都是2）</p>
<p>接下来将上图的var改成let</p>
<p><img src="/ES6/db01e9ca8584b0f2eff58db2745193dd.png" alt=""></p>
<p>注意，for循环的每一轮循环都有自己的变量i，且由于他们分别处于不同的块级作用域，因此互不影响（这里的let
I = 0,let I = 1,let I = 2 这三个i互不影响）</p>
<p><strong>解释一下为什么这里输出是0和1：</strong></p>
<p>因为let使得函数在执行的时候去找上级i的时候是去找同一个块级作用域（或者说是包裹函数自己的那个块级作用域）中的变量i（刚才说了每一次循环都会产生一个块级作用域，块级作用域中的i互不影响）</p>
<p>（这里的查找变量i是指在<strong>同一块级作用域</strong>中相对函数自身来讲的上级的变量i）</p>
<p>因此i该是几还是几，所以两个函数输出的是0和1</p>
<p>2.</p>
<p>类似的还有这个案例</p>
<p><img src="/ES6/b844cc1c60c0c573504d822aa9100900.png" alt=""></p>
<p>点击事件失效，道理跟上面是一样的</p>
<p><img src="/ES6/cd4a022aee8f6c20dc5964be0d908fb7.png" alt=""></p>
<h3 id="const">const</h3>
<p><img src="/ES6/8e050d789f997dfb92d7f4d1ea1ded88.png" alt=""></p>
<p>const声明的变量也具有块级作用域</p>
<p><img src="/ES6/e0fcca250965c36b514e03c6c4fd7cb9.png" alt=""></p>
<p>跟let一样，块级作用域之间的变量互不影响，因此这里输出的顺序是：20, 10, not
defined</p>
<h4 id="const变量必须赋初始值">const变量必须赋初始值</h4>
<p><img src="/ES6/e5668e5b575bcc1c15b3a9b0fd1bcedd.png" alt=""></p>
<h4 id="const声明的变量赋值之后不能修改">const声明的变量赋值之后不能修改</h4>
<p><img src="/ES6/2cf428fc074824b7f139041b792fbffe.png" alt=""></p>
<p>注意我们单独去找ary里面的值并进行修改是可以的，因为这个操作并没有改掉ary的地址，但是直接给ary赋值一个新的数组就不行了，因为这个操作就相当于直接把他的地址给改掉了，会报错，如上图</p>
<p><strong>总结来讲就是简单数据类型值不可修改，复杂数据类型数据结构内部的值可以更改，但是该复杂数据本身不可更改</strong></p>
<h4 id="const跟let一样也有块级作用域">const跟let一样也有块级作用域</h4>
<p><img src="/ES6/61be1c76eb1a9d71e03829b643b2aaa1.png" alt=""></p>
<h3 id="letconstvar的区别">let、const、var的区别</h3>
<p><img src="/ES6/7b4175dcadfa207d38c79dc79ca32b66.png" alt=""></p>
<p>const要比let效率高，因此如果是恒定不变的或者不需要变化的值应该尽量使用const（因为const定义的常量不需要变化，JavaScript解析引擎不需要时时刻刻监控值的变化，所以const关键字要比let关键字效率高）</p>
<h3 id="解构赋值">解构赋值</h3>
<p><img src="/ES6/cea4be5b944b1494427e1e581d662ffb.png" alt=""></p>
<h4 id="如果解构的变量数量跟右边数组的长度不对应">如果解构的变量数量跟右边数组的长度不对应</h4>
<p><img src="/ES6/e4922a22bf4cfc592337747741df8f78.png" alt=""></p>
<p>上下两个foo都为undefined</p>
<h4 id="对象解构">对象解构</h4>
<p><img src="/ES6/2aa6c9e0e19fbc59654966c92aa97b35.png" alt=""></p>
<p>在ES6之前，我们是这么取的：</p>
<p>person.name，person.age，这样要重复声明两次let变量会非常麻烦，ES6之后直接用对象解构就可以了</p>
<p>当然也可以直接let {name} = person; 这样可以直接拿到这个name</p>
<h4 id="对象解构的另一种方法">对象解构的另一种方法</h4>
<p><img src="/ES6/268765a4c3f3fc9034e1294b2b0c6dd7.png" alt=""></p>
<p>直接写清楚key: value去解析</p>
<p><img src="/ES6/4126a146a72bb217197aa90d0766d975.png" alt=""></p>
<h3 id="箭头函数">箭头函数</h3>
<p><img src="/ES6/6dd7b01aba427462aff5c783dbedab86.png" alt=""></p>
<p><img src="/ES6/84e5e30ffd3df4f75c81f538768858a5.png" alt=""></p>
<p>如果函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p>
<p><img src="/ES6/4f6d23ffb5f56a7a4f91fba5f8ce81a9.png" alt=""></p>
<p>如果形参只有一个，也可以省略小括号</p>
<p><img src="/ES6/d2fc741ccda4990ea3152f7727b5d328.png" alt=""></p>
<p><img src="/ES6/535bec3755522f60b494aba79796cbc4.png" alt=""></p>
<h4 id="箭头函数不绑定this箭头函数的this指向的是函数定义位置的上下文this">箭头函数不绑定this，箭头函数的this指向的是函数定义位置的上下文this</h4>
<p>注意无论用call、bind等都无法改变this指向</p>
<p><img src="/ES6/0ebe529ff8ff0c99f2261db4706f9e88.png" alt=""></p>
<p>原先我们再上图return的位置写的是return function(){console.log(this)}
如果这么写的话最后调用resFn()的时候this指向的一定是window，但是箭头函数不一样，箭头函数不绑定this，且this指向的是函数定义位置上下文的this，所以在这里return的箭头函数打印的this还是name为“张三”的obj</p>
<h4 id="箭头函数不能作为构造实例化对象">箭头函数不能作为构造实例化对象</h4>
<p><img src="/ES6/78197936784cd5422f333070551306c1.png" alt=""></p>
<h4 id="箭头函数不能使用arguments变量">箭头函数不能使用arguments变量</h4>
<p><img src="/ES6/fbcd4108dddd374637611ea25c2e2d39.png" alt=""></p>
<h4 id="经典易错题">经典易错题</h4>
<p>1、</p>
<p><img src="/ES6/9daa0286697990eaa261f32978d05c16.png" alt=""></p>
<p>这里输出的是undefined</p>
<p>我们刚刚讲了箭头函数的this指向上下文的this，上面那个案例上下文是指在函数所产生的作用域内的上下文，而这里箭头函数定义在一个obj内，<strong>而obj不能产生作用域</strong>，因此这里箭头函数的上下文事实上是全局作用域，因此this指向的其实是全局作用域，而全局作用域并没有定义age</p>
<p><img src="/ES6/e19a6c16a6ec012ed921f82412862aab.png" alt=""></p>
<p>下面我们在全局作用域下定义一个age，结果显示的就是100</p>
<p>（这里其实换做原先的写法 say:
function(){alert(this.age)}，那最后在调用的时候谁调用this就指向谁，所以会输出20）</p>
<p>2、</p>
<p>在外层套了一个setTimeout之后this指向window导致属性更改失败：</p>
<p><img src="/ES6/f8ad6121ea77b4db3fcc142cfe55551f.png" alt=""></p>
<p>解决方法：</p>
<p>原先：</p>
<p><img src="/ES6/e68297a0adcac76c68c879f3bde52a4f.png" alt=""></p>
<p>使用箭头函数：</p>
<p><img src="/ES6/faa7b04a0fb23734b080bb85d8960bbe.png" alt=""></p>
<p>3、</p>
<p>从数组中返回偶数元素：</p>
<p>原先：</p>
<p><img src="/ES6/c465695480dd61eab6a8c4d800d661a6.png" alt=""></p>
<p>使用箭头函数：</p>
<p><img src="/ES6/bab69a23d47f33b7800971e75b5f29b4.png" alt=""></p>
<p>使用箭头函数之后的更加简化的版本：</p>
<p><img src="/ES6/42c8bc71df46a5ba82db7ba63f54a3c2.png" alt=""></p>
<h4 id="总结">总结</h4>
<p><img src="/ES6/4f007418063683dace2a15379affd5e7.png" alt=""></p>
<p>箭头函数适合与this无关的回调，比方说定时器、数组方法的回调</p>
<p>但是，箭头函数不适合与this有关的回调，比方说事件的回调、对象的方法的回调，比如上图，我们知道对象不产生块级作用域，所以上面的getName中的this指向的其实是window（正确的做法是写成原来的function而不是箭头函数）</p>
<p>但是，在某些情况下这样用反而能方便我们的实现</p>
<h3 id="rest剩余参数">rest（剩余参数）</h3>
<p><img src="/ES6/25c00f7987542d86da1a858eaefb5302.png" alt=""></p>
<p>注意…args必须写在其他参数的后面</p>
<p><img src="/ES6/47a192d26c312e2cf5dcbaab1301c876.png" alt=""></p>
<p>我们想要实现计算括号内的数据之和，在ES6之前通常会用arguments去拿取可变参数，但是箭头函数里面没有arguments</p>
<p><img src="/ES6/7e9e01b9d7417db1983e8cb15d950390.png" alt=""></p>
<p>现在的写法是这样的，用…args去拿可变参数，然后用forEach去计算累加，注意在forEach里面的箭头函数要像上图这样写（其实就是Java的lambda表达式）</p>
<h4 id="rest代替arguments">rest代替arguments</h4>
<p><img src="/ES6/8f53c48852c38d41e1af150442559ad8.png" alt=""></p>
<p>ES5的arguments本质上是一个对象</p>
<p><img src="/ES6/c1fc6f943dd052daa75e436bc170bf22.png" alt=""></p>
<p>而ES6的rest他是一个数组，可以使用filter、some等函数</p>
<h4 id="剩余参数与解构配合使用">剩余参数与解构配合使用</h4>
<p><img src="/ES6/49f3b82a7d5df6fdf094a2486ddb9f63.png" alt=""></p>
<h3 id="array的扩展方法扩展运算符展开语法">Array的扩展方法，扩展运算符（展开语法）</h3>
<p><img src="/ES6/ce4378b93b5ac5777ffc29f22852db00.png" alt=""></p>
<p>使用扩展运算符我们可以得到数组或者对象转为用逗号分隔的参数序列，注意这里是有逗号分隔的，当我们将用逗号分隔的参数序列放到console.log（）方法中之后，逗号会被当做参数的分隔符，所以这里的逗号才没有输出，为了验证逗号被当作参数分隔符，我们直接打印console.log(1,2,3)，发现输出的确实是1
2 3，这个特性会在后面的异步中被广泛应用</p>
<p><img src="/ES6/d5c1abe11c82f960a18cf2b6c111bf0c.png" alt=""></p>
<h4 id="扩展运算符用于合并数组">扩展运算符用于合并数组</h4>
<p><img src="/ES6/fe912494a146c1aa7fe7d388d5916177.png" alt=""></p>
<p><img src="/ES6/e4c8c7631f2e77e969c6df576f01192c.png" alt=""></p>
<h5 id="es5合并数组的做法">es5合并数组的做法</h5>
<p>a1.concat(a2)，现在有了扩展运算符就不用这么麻烦了</p>
<h4 id="扩展运算符用于克隆数组">扩展运算符用于克隆数组</h4>
<p><img src="/ES6/0b2bd9072920311dbc53f84fa1ef83f0.png" alt=""></p>
<h4 id="扩展运算符将伪数组转化为真正的数组">扩展运算符将伪数组转化为真正的数组</h4>
<p><img src="/ES6/df452ed8690c3b8d80bfca08e823f6f7.png" alt=""></p>
<p><img src="/ES6/1b4c2d5eeac48489b6115c44330a05be.png" alt=""></p>
<p>我们知道document.getElementsByTagName()获取来的是伪数组，本质上是一个对象：</p>
<p><img src="/ES6/96fa882097cd7bc45029fe5f2e9a7df9.png" alt=""></p>
<p>伪数组变真正的数组之后就能用数组的方法了</p>
<p><img src="/ES6/7ab500dc96821db16d30a74aca374e4c.png" alt=""></p>
<h4 id="arrayfrom-将类数组或可遍历对象转换为真正数组">Array.from() 将类数组或可遍历对象转换为真正数组</h4>
<p><img src="/ES6/959d4a89d225f6c27886941a8afd65e8.png" alt=""></p>
<p><img src="/ES6/0493c233ad729503dee166170266b8b1.png" alt=""></p>
<p>通过Array.from()将伪数组直接转化为真正数组，</p>
<p><strong>注意上面arrayLike的这个对象竟然是一个伪数组</strong></p>
<h5 id="arrayfrom中的第二个参数">Array.from()中的第二个参数</h5>
<p><img src="/ES6/3ed944eae68acff8c7343652f94dda82.png" alt=""></p>
<p>第二个参数其实就是一个函数，通过该函数来遍历改变数组中的每一个值（类似python的lambda）</p>
<p><img src="/ES6/8232263ec331daee7ad0ac117191d329.png" alt=""></p>
<h4 id="查找方法find">查找方法：find()</h4>
<p><img src="/ES6/274d840baed98fc3e638bfbc75a36ab3.png" alt=""></p>
<p><img src="/ES6/b9ce798e3754c24314684a120e90be49.png" alt=""></p>
<p>查找数组中符合条件的第一个元素，找不到返回undefined</p>
<h4 id="返回index的查找方法findindex">返回index的查找方法：findIndex()</h4>
<p><img src="/ES6/4197988cc85662d02b858d8cb80f211c.png" alt=""></p>
<p>返回第一个符合条件的元素的下标</p>
<h4 id="判断是否包含方法includes">判断是否包含方法：includes()</h4>
<p><img src="/ES6/6d862b0d701032ea795afbb7141b5df4.png" alt=""></p>
<p>ES6之前我们用indexOf来判断数组中是否存在某个值，ES6之后我们用includes来判断</p>
<h3 id="string的扩展方法">String的扩展方法</h3>
<h4 id="模板字符串">模板字符串</h4>
<p><img src="/ES6/7f7d642364ef309379489f7d8a327e85.png" alt=""></p>
<p><img src="/ES6/561dacb97baeb72d7db25ede11c9d7df.png" alt=""></p>
<p><img src="/ES6/b402fc67eda4e80a4aa203865c583745.png" alt=""></p>
<p>两个字符串都需要用反引号</p>
<h5 id="模板字符串中可以换行">模板字符串中可以换行</h5>
<p><img src="/ES6/7494978559061020d470a307de83a2e6.png" alt=""></p>
<p>由于可以换行，模板字符串可以写的非常美观</p>
<h5 id="模板字符串可以调用函数">模板字符串可以调用函数</h5>
<p><img src="/ES6/eaf4c2f0d3a3f8ba683f26721510a2ee.png" alt=""></p>
<h4 id="startswith与endswith">startsWith()与endsWith()</h4>
<p><img src="/ES6/3c778f39f003ee94e9b0f04cce35bf60.png" alt=""></p>
<h4 id="repeat">repeat()</h4>
<p><img src="/ES6/b75e9f260c0e2167b09fc66be2c833f8.png" alt=""></p>
<h3 id="set">Set</h3>
<p><img src="/ES6/d8c40de1e3bcbe92f96e0b94751627d6.png" alt=""></p>
<h4 id="属性size">属性size</h4>
<p><img src="/ES6/8a68fe11520bba87bcc378b559fe9012.png" alt=""></p>
<h4 id="set配合解构">set配合解构</h4>
<p><img src="/ES6/5d65384c8b72330885489cd2b0628654.png" alt=""></p>
<p>输出的ary是[“a”, “b”]</p>
<h4 id="adddeletehasclear">add()、delete()、has()、clear()</h4>
<p><img src="/ES6/b2d7cdbdeaf16254458a1c0cfad7b980.png" alt=""></p>
<p>注意，add()返回Set结构本身</p>
<h4 id="foreach遍历set">forEach遍历Set</h4>
<p><img src="/ES6/5614dbbcf608cb5c2e6ab78377ee5531.png" alt=""></p>
<h4 id="for-of遍历set">for of遍历Set</h4>
<p><img src="/ES6/b30b0166b5c83fe93417893b4459d1de.png" alt=""></p>
<h4 id="数组去重">数组去重</h4>
<p><img src="/ES6/986408e0bad5f68a3c4fb67d71227290.png" alt=""></p>
<h4 id="交集">交集</h4>
<p><img src="/ES6/8777d424a8f24fdcfd10cdb7ccaaafde.png" alt=""></p>
<p>上图代码还可以这么写：</p>
<p><img src="/ES6/d6c2d2d2dd3e695fe91d65513f7a7495.png" alt=""></p>
<h4 id="并集">并集</h4>
<p><img src="/ES6/cbc595862dd3f2c8a875f2152e6fb450.png" alt=""></p>
<h4 id="差集">差集</h4>
<p><img src="/ES6/b33489602f39e1f0e15988472c90f11f.png" alt=""></p>
<h3 id="map">Map</h3>
<p><img src="/ES6/53bed9843b18d78e0e7cd95a2988cc0c.png" alt=""></p>
<h4 id="属性size-1">属性size</h4>
<p><img src="/ES6/ba243cc00569392f8a80dcaa5877db97.png" alt=""></p>
<h4 id="setgethasclear">set()、get()、has()、clear()</h4>
<p><img src="/ES6/f3f8d2ddbc5b818e5a1aa4341db1a389.png" alt=""></p>
<p>注意，map里面的key还可以是对象，value还可以是函数，如上图</p>
<p><img src="/ES6/9810f3c420e5b40c2eadd62e9c3f9eea.png" alt=""></p>
<h4 id="for-of遍历">for of遍历</h4>
<p><img src="/ES6/60dfa7657b1ebafa56531f9dec779ea8.png" alt=""></p>
<p>注意for
of遍历出来的东西并不是values，而是一个数组，其中第一个放的是key，第二个放的是value</p>
<h3 id="对象简化写法">对象简化写法</h3>
<p><img src="/ES6/08f3459f780d5ea9107d8f0e997bd378.png" alt=""></p>
<p>可以写成：</p>
<p><img src="/ES6/272880225425c6dabf602a02ff8bfd1e.png" alt=""></p>
<p>如果是方法的话：</p>
<p><img src="/ES6/85ef29e08613aa70f63b71d65ad489bf.png" alt=""></p>
<p>可以写成：</p>
<p><img src="/ES6/19dfdedd7d58bb1670198513195bf5ed.png" alt=""></p>
<h3 id="es6允许给函数参数赋值初始值">ES6允许给函数参数赋值初始值</h3>
<p><img src="/ES6/ee4ac88af6453ddbc1aed6993ddd139d.png" alt=""></p>
<h3 id="es6允许参数使用解构进行赋值">ES6允许参数使用解构进行赋值</h3>
<p><img src="/ES6/c9195bbc99a26ac87ce8f04f3431020d.png" alt=""></p>
<h4 id="允许在参数解构赋值的情况下再给参数赋值">允许在参数解构赋值的情况下再给参数赋值</h4>
<p><img src="/ES6/27ee20ce1a4c91925559b01373eadc84.png" alt=""></p>
<p>注意这里还没传host，但是有个默认值所以还是可以获取的</p>
<p><img src="/ES6/e8e4e91ffb7be78f33390ae70cb2606d.png" alt=""></p>
<p>当然，传了就是用传了的值</p>
<h3 id="symbol基本使用">Symbol基本使用</h3>
<p><img src="/ES6/1242e9be9898e7ea4361ed8ce867c4d5.png" alt=""></p>
<p><img src="/ES6/ad0157404df4f6d8c3e3ca470b08184f.png" alt=""></p>
<p>Symbol这种类型是ES6引入的一种新的数据类型，如上图</p>
<p><img src="/ES6/034c2cc6bdfe03b9a2de8bc23734f117.png" alt=""></p>
<p>注意Symbol里面写的东西，就比方说上面的“尚硅谷”其实类似于一种注释（这里叫做描述字符串），像这里用Symbol来创建的话即时里面的描述字符串是一样的，两个Symbol也是不一样的，如上图</p>
<h4 id="symbolfor">Symbol.for()</h4>
<p>这是第二种创建Symbol的方式，该方式可以通过描述字符串来得出唯一的Symbol值：</p>
<p><img src="/ES6/62230b4771faf434146d624cf022a73d.png" alt=""></p>
<p>如上图s4、s5的描述字符串是相同的，那他们两个拿到的Symbol值就是同一个。这也是与用Symbol创建的区别。</p>
<h4 id="symbol不能与其他数据进行运算">Symbol不能与其他数据进行运算</h4>
<p><img src="/ES6/0a6666d59ae7fdb5cecc7d49318eb99b.png" alt=""></p>
<p>所有运算和比较在Symbol这里都是不可行的</p>
<h4 id="总结js中的所有数据类型">总结JS中的所有数据类型</h4>
<p><img src="/ES6/87329de95759d88c713039ae59c342c7.png" alt=""></p>
<h4 id="symbol的作用或者使用场景">Symbol的作用或者使用场景</h4>
<h1 id="有时候我们给对象添加方法但是不确定它里面是否已经有了该名称命名的方法比如下图我们完全看不到对象game里面到底有哪些方法如果直接gamefunction1">有时候我们给对象添加方法但是不确定它里面是否已经有了该名称命名的方法（比如下图，我们完全看不到对象game里面到底有哪些方法），如果直接game.function1</h1>
<p>function(){}这样写是可以的，但是有很大的风险（命名冲突导致覆盖），这个时候就可以先用Symbol()做一步初始化：</p>
<p><img src="/ES6/5503c268f0e8d2644618409d96b85919.png" alt=""></p>
<p>比方说我们先声明了一个methods对象里面用Symbol初始化up和down两个方法，再来给game赋值，如上图</p>
<h4 id="symbol作为对象的属性名symbolxxx-function">Symbol作为对象的属性名（{[Symbol(‘xxx’)]: function(){}}）</h4>
<p>原先我们给对象添加属性：</p>
<p><img src="/ES6/b3acc8a6c4d8c2418d8150b8871c7199.png" alt=""></p>
<p>使用Symbol()添加属性：</p>
<p><img src="/ES6/92d02efd41c90e20cae713d31a2819da.png" alt=""></p>
<p>但是由于Symbol()是一个表达式，是动态的，不能直接写：Symbol():
function(){}，不然会报错</p>
<p>正确的做法是给Symbol()加上中括号：[Symbol()]: function(){}，如上图</p>
<h4 id="symbol内置值">Symbol内置值</h4>
<p><img src="/ES6/2abb169d285806d426fc12ffa68a7e65.png" alt=""></p>
<p><img src="/ES6/cc43e1d22c365bb937a674a4a1838d36.png" alt=""></p>
<p><img src="/ES6/060c47d0ea1e5948198e9f20918554f1.png" alt=""></p>
<p>上图Symbol的 . 后面的这些属性都是Symbol的属性，而Symbol.xxx
这个整体是Symbol对象的属性</p>
<p>这些方法跟普通方法不一样，他在某些特定的情况下会触发执行，来改变对象在某些特定场景下的表现，说白了就是扩展对象功能</p>
<p>注意这些都是自动的，手动设置之后不需要我们手动调用</p>
<h5 id="symbolhasinstance">Symbol.hasInstance</h5>
<p><img src="/ES6/5390cd4caba6a8367ae5979389a1b56c.png" alt=""></p>
<p>注意这里Symbol.hasInstance要用中括号括起来</p>
<p>而且还可以传入param参数：</p>
<p><img src="/ES6/136832ac8084cd2f8cb18e2dd9c7d107.png" alt=""></p>
<p>而且还可以返回true|false：</p>
<p><img src="/ES6/2fbf3b37e17bd64a9f238a4cccb13e9e.png" alt=""></p>
<p>这就是Symbol.hasInstance的作用，可以自己去控制类型检测</p>
<h5 id="symbolisconcatspreadable">Symbol.isConcatSpreadable</h5>
<p>控制合并的数组是展开合并还是整体合并：</p>
<p><img src="/ES6/6c931859c7b3449bb7d009f251278b63.png" alt=""></p>
<p>这里设置数组arr2的Symbol.isConcatSpreadable属性为false，现在合并arr1和arr2，发现结果是：[1,2,3,Array(3)]，这个Array(3)还能进一步展开；</p>
<p>如果设置Symbol.isConcatSpreadable为true，那就是正常合并，结果为[1,2,3,4,5,6]</p>
<h3 id="迭代器iterator">迭代器(iterator)</h3>
<p><img src="/ES6/dd2cd32599e582185d53135d0e2283e9.png" alt=""></p>
<p>这里的iterator接口指的就是对象里的一个属性，这个属性的名字叫做Symbol.iterator</p>
<h4 id="for-in">for in</h4>
<p><img src="/ES6/45a5e9c2a71b01b736a0d3158814e6eb.png" alt=""></p>
<p>for in 很熟悉，就不多说了，他保存的是键名</p>
<h4 id="for-of">for of</h4>
<p><img src="/ES6/16de02257f2fed97b503a023286ee201.png" alt=""></p>
<p>for of 保存的是键值</p>
<p>那么为什么数组也能用for of呢？那是因为数组里面有一个属性叫做Symbol.iterator：</p>
<p><img src="/ES6/edf988cd355b3543c8f2019bda8b7100.png" alt=""></p>
<p>仔细看这个Symbol.iterator对应的是一个函数</p>
<h4 id="原理">原理</h4>
<p><img src="/ES6/32147fb2fd6865e7cd70e4ebabec5cde.png" alt=""></p>
<p>我们来看一下Symbol.iterator这个函数的内部：</p>
<p><img src="/ES6/2eb25df5b7a18c5a537dd556e408457d.png" alt=""></p>
<p>注意，由于Symbol.iterator是一个函数，所以我们在给它加了一层中括号的同时后面还要加一个小括号让他得以取出真正的Iterator迭代器，如上图（xiyou是上上图的那个数组，xiyou[Symbol.iterator]拿出来的就是xiyou这个数组的Symbol.iterator这个属性，而我们刚刚说了它是一个函数，所以要用xiyou<a href="">Symbol.iterator</a>
来取出该数组真正的Iterator迭代器，并把它保存到iterator变量中）</p>
<p>之后我们发现Iterator的内部有一个next方法，如上图</p>
<p><img src="/ES6/a3a6431b1b8face54c8348d618296711.png" alt=""></p>
<p>next方法执行结果如上图</p>
<p><img src="/ES6/32f0b6d01a3ecc36e13da6e082688fc1.png" alt=""></p>
<p>我们发现迭代器next()方法返回的内容里面除了value还有一个done，它是用来表示完成状态的，当迭代完成，也就是指针到达数组最后一个元素的后面（此时指针指向空）的时候，done就会由false变为true</p>
<h4 id="应用场景">应用场景</h4>
<p><img src="/ES6/2eec539086f228023a4b2e6e1707480b.png" alt=""></p>
<p>当我们需要自定义遍历数据的时候，就需要使用迭代器了</p>
<p>比方说我现在有一个需求：我需要使用for of来遍历banji对象中的stus数组中的内容：</p>
<p><img src="/ES6/f06ccf6c2900dfe68247dce1ec87c3bb.png" alt=""></p>
<p>但是banji对象此时并没有Symbol.iterator属性，所以他是用不了for
of的，那么我们给它加一个：</p>
<p><img src="/ES6/f074eb22d844e53a4ef2aac5fb4beac1.png" alt=""></p>
<p>按照Symbol.iterator的需要，里面需要返回一个对象，并且对象里面需要有next方法，并且next方法需要返回一个包含value和done的对象，如上图</p>
<p>此时我们给value随便指定一个值，并执行上图代码，发现他会无限执行，那是因为done一直是false状态</p>
<p><img src="/ES6/cfdb5584038dbac23c9e763c17d0af7c.png" alt=""></p>
<p>要解决上面的问题，我们需要一个index下标来控制整个流程，这里用_this=this的方法来解决this指向问题，当然也可以直接用箭头函数，如上图</p>
<h3 id="生成器yield">生成器（yield）</h3>
<p><img src="/ES6/33a1cac1289aa60008b2e43a2dc59908.png" alt=""></p>
<p><img src="/ES6/009de5f2665a35c0375b993629418e42.png" alt=""></p>
<p>yield可以看作是函数代码的分隔符，三个yield产生四块代码</p>
<p><img src="/ES6/ee18f2da04fcea4effe50b0f7183e211.png" alt=""></p>
<p>直接输出上图iterator发现它是一个生成器，只有调用next才会输出值</p>
<h4 id="使用next执行yield代码块">使用next执行yield代码块</h4>
<p><img src="/ES6/e29427b2561b5780dcfa77543fe0adb4.png" alt=""></p>
<p>由于yield只是返回值，所以执行之后并没有打印yield里面的内容</p>
<p><img src="/ES6/8afb5a361c2e1ba718c13f77e64cf9fd.png" alt=""></p>
<h4 id="使用for-of遍历yield函数">使用for of遍历yield函数</h4>
<p><img src="/ES6/7eb8c8a19bc8382f4908956fec3ca32a.png" alt=""></p>
<p>这里打印的是yield的返回值</p>
<h4 id="生成器函数中可以传入实参">生成器函数中可以传入实参</h4>
<p><img src="/ES6/3c931f74820a5409d570f76605822c87.png" alt=""></p>
<h4 id="生成器函数的next中也可以传入实参">生成器函数的next中也可以传入实参</h4>
<p><img src="/ES6/63f142e1c92848501a11d28965f411fd.png" alt=""></p>
<p>注意，这个传入的“BBB”将作为第一个yield的整体返回值（我们先调用了一次next，说明第一个yield的代码块已经执行完毕，再次调用next并传入“BBB”，在第二个代码块中我们想要输出第一个代码块yield的整体返回值，本来这个值是undefined（注意并不是111），但是现在我们自己传了“BBB”进去，所以他就变BBB了）</p>
<p><img src="/ES6/9f636d77e097996803ed5647d9d80ca7.png" alt=""></p>
<h4 id="生成器函数实例">生成器函数实例</h4>
<p>1、</p>
<p>生成器是js里面实现异步编程的解决方案，包括文件操作、网络操作（ajax，request）、数据库操作</p>
<p>有一个需求：1s后输出111， 2s后输出222， 3s后输出333</p>
<p><img src="/ES6/ecaa039142d9f7c8994bf3db2720c427.png" alt=""></p>
<p>回调地狱了</p>
<p>现在用生成器函数来做一次：</p>
<p><img src="/ES6/16589360d8baa54dd54f140b95c389a5.png" alt=""></p>
<p><img src="/ES6/c7d43e890aa3868217b0897d0d9f9893.png" alt=""></p>
<p><img src="/ES6/53ac1ee93058a03160ad75e6be3c1f79.png" alt=""></p>
<p>但是这样写只会出现111，因为在111的函数里面没有写调用222的函数，在222的函数里也没有写调用333的函数</p>
<p>正确写法：</p>
<p><img src="/ES6/b8de6f7835a0c99f673e232807fecc6e.png" alt=""></p>
<p><img src="/ES6/debf829ff4917cc56ed6b39db2a8a1c6.png" alt=""></p>
<p>在每一个函数里面再调用iterator.next()，注意这个iterator是在代码最后调用的这个iterator</p>
<p>注意，肯定有人会想：</p>
<p>为什么不直接调用one();two();three();呢？那是因为在实际场景中，后面的函数进行是需要依赖前面的函数的返回值的，所以这么调不符合实际场景</p>
<p>2、</p>
<p><img src="/ES6/05afad67e4f29b6ece9fb0c3549d3cbb.png" alt=""></p>
<p>我们来看这个例子，有一个问题：data放在执行函数里面并没有返回，因此无法获取也无法更改</p>
<p><img src="/ES6/5c57e1a8562b8f8080c98752070079bb.png" alt=""></p>
<p><img src="/ES6/bb052e227567478381dc24ccf13d529c.png" alt=""></p>
<p>那么这里可以用到之前讲过的一个方法：</p>
<p>在next()里面传值，如上图，上图中是第二个next()里面传入了数据，因此他将作为第一个yield的返回结果。</p>
<h4 id="小结">小结</h4>
<p>yield的函数看起来跟同步差不多，其实它是异步的</p>
<h3 id="promise">Promise</h3>
<p>读取多个文件：</p>
<p><img src="/ES6/7f8665c3429b3e9dca037cd4471cfdfd.png" alt=""></p>
<p>上图回调地狱，每一层函数里面的参数不能重名，比方说上图的data，这也是纯回调函数的一个弊端</p>
<p>Promise可以完美解决</p>
<p>基于Promise的读取多个文件：</p>
<p><img src="/ES6/3e13efa2b48722fed496c5ecf5e1b98b.png" alt=""></p>
<p>想当于把每一层的value叠到上一层的value里面，最后再输出</p>
<p>当然最终的value是一个数组，我们当然可以用.join()的方法把它变成字符串：</p>
<p><img src="/ES6/bb5426992a4595322a749349100440f3.png" alt=""></p>
<h3 id="class">class</h3>
<p><img src="/ES6/5f94e7a2c1928b603e21060fae0dd05e.png" alt=""></p>
<p>ES5：</p>
<p><img src="/ES6/cb4f276f6df9e52305a4f64d6b150005.png" alt=""></p>
<p>ES6：</p>
<p><img src="/ES6/a8ad8213ac6e0e1c9bcac6ca2ce22fd2.png" alt=""></p>
<h4 id="class的static属性">class的static属性</h4>
<p>ES5：</p>
<p><img src="/ES6/aabe75c1f001e4fb1533c0b031cc24ac.png" alt=""></p>
<p>可以看到类的静态属性实例是无法访问的，类的静态函数实例也是无法访问的。如果要访问的话应该把属性或者函数直接写在构造函数里面，或者直接写在原型里面：</p>
<p><img src="/ES6/044bacb01fb72a881133889434a76a2a.png" alt=""></p>
<p>ES6：</p>
<p><img src="/ES6/f47b7c3d4e89db2f489b357360478d67.png" alt=""></p>
<h4 id="继承">继承</h4>
<p>ES5：</p>
<p><img src="/ES6/36554f51e31457d924334a4cea3d04d8.png" alt=""></p>
<p><img src="/ES6/4b4ec99140d861f06cdc9640a3768514.png" alt=""></p>
<p>ES6：</p>
<p><img src="/ES6/253841e9b8bd156a77c0e614c5d93d06.png" alt=""></p>
<p><img src="/ES6/d9e03b196704d176418f05c49838db4c.png" alt=""></p>
<h4 id="重写">重写</h4>
<p>直接在子类里面重写父类同名方法即可，注意！子类的同名方法里面不能写super（）去调用父类同名方法方法的：</p>
<p><img src="/ES6/9da84e987e118e50afaff8001f001034.png" alt=""></p>
<h4 id="getter和setter">getter和setter</h4>
<p>先来看看python的getter和setter：</p>
<p><img src="/ES6/01ce5bbc87f5b9a7916b76628911c387.png" alt=""></p>
<p><img src="/ES6/943d6922525d3cddd8afaf094fd34871.png" alt=""></p>
<p>python是用@Property和@xxx.setter来实现getter和setter的，我们也知道，设置了@Property的方法会变成实例的属性，可以由实例直接调用的，其实JS的getter与setter和python是完全一样的。</p>
<p>JS的getter和setter：</p>
<p><img src="/ES6/99894edf2c644d2202dc9af87013fc91.png" alt=""></p>
<p>是直接在方法前面加get和set</p>
<p>这个时候可以直接由实例调用price这个属性</p>
<h5 id="技巧">技巧</h5>
<p>一般来讲getter适用于对象的某些动态的数据的计算，比方说算平均值，他整体的数据是会不断变化的，这个时候用getter就会非常方便，而setter适用于设置的时候判断传入数据是否合法，并进一步决定是否赋值</p>
<h3 id="数值扩展">数值扩展</h3>
<p><img src="/ES6/b887f4fcc3be2cd1d38d625f5ed229a0.png" alt=""></p>
<h4 id="numberepsilon">Number.EPSILON</h4>
<p>是一个非常小的数，是js能表示的最小精度</p>
<p>主要用于浮点数的运算，对精度做一个设置</p>
<p><img src="/ES6/705a4af82d9c82931f631a70b2be5d0e.png" alt=""></p>
<p>我们发现上面这个0.1+0.2是不等于0.3的</p>
<p>有了Number.EPSILON就可以进行0.1+0.2和0.3的比较了：</p>
<p><img src="/ES6/090fa6bb863e76eb5f73843b49dbfd21.png" alt=""></p>
<h4 id="二进制和八进制">二进制和八进制</h4>
<p><img src="/ES6/598b37380ec889d007704a2a6d57d6f7.png" alt=""></p>
<h4 id="numberisfinite">Number.isFinite</h4>
<p>检测一个数值是否为有限数</p>
<p><img src="/ES6/c190da977406cebc37f4e68747872c2c.png" alt=""></p>
<p>100/0竟然不报错？？？</p>
<h4 id="numberisnan">Number.isNaN</h4>
<p><img src="/ES6/f35b1e8c8be20699fc43d49a1fc8ef68.png" alt=""></p>
<h4 id="numberparseint与numberparsefloat">Number.parseInt与Number.parseFloat</h4>
<p><img src="/ES6/9786370b3b97d0c0739b86c2b50baae7.png" alt=""></p>
<h4 id="numberisinteger">Number.isInteger</h4>
<p><img src="/ES6/dfbf785d6c1eb21ef94dc3beda8b26d0.png" alt=""></p>
<h4 id="mathtrunc">Math.trunc</h4>
<p><img src="/ES6/b1a3245e91dfcb99079946918021fb17.png" alt=""></p>
<h4 id="mathsign">Math.sign</h4>
<p><img src="/ES6/cdbfd7bd277a248c89e2de713826add0.png" alt=""></p>
<h3 id="对象方法扩展">对象方法扩展</h3>
<h4 id="objectis">Object.is</h4>
<p>用于比较两个数值是否相等，类似于 ===</p>
<p>但是当判断NaN和NaN是否相等的时候 === 会显示不等（任何东西与NaN比较
除非是写了一个不等号，否则都是返回false）， 而Object.is就会返回true：</p>
<p><img src="/ES6/8f8b3fe796607bc33d41c7f92e6b7498.png" alt=""></p>
<h4 id="objectassign">Object.assign</h4>
<p>对象的合并</p>
<p><img src="/ES6/40127189573db91fc31e434bfc9e26b3.png" alt=""></p>
<p>注意：如果前一个有某个属性，后一个没有，那就以前一个为准，如果前一个没有，后一个有，那就以后一个为准，如果前一个有，后一个也有，那还是以后一个为准</p>
<h4 id="objectsetprototypeof与objectgetprototypeof">Object.setPrototypeOf与Object.getPrototypeOf</h4>
<p><img src="/ES6/2f46bbcc45d3097d53d144eaa8d99f5e.png" alt=""></p>
<p>可以将某个对象的原型设置为某个指定的对象</p>
<p><img src="/ES6/27fab589c419424eaba4c05a8496f49f.png" alt=""></p>
<p>当然也可以用Object.getPrototypeOf获取，如上图</p>
<p>当然，我们不建议这么做，建议在Object.create()创建对象的时候就把他的原型设置上，这样效率是最高的</p>
<h4 id="objectcreateprotopropertiesobject">Object.create(proto[,propertiesObject])</h4>
<p><img src="/ES6/09543d982a6373c334286bd629acf6d4.png" alt=""></p>
<p><img src="/ES6/eb44626ee4824333054275108b046e56.png" alt=""></p>
<p>第一个参数指定prototype，第二个参数参考Object.defineProperty()</p>
<h3 id="模块化">模块化</h3>
<p><img src="/ES6/a51ebfdde08eac20e452311e2771c33d.png" alt=""></p>
<ol>
<li>
<p>防止命名冲突：我在A.js中有变量a，我在B.js中也有变量a，两者是不冲突的；</p>
</li>
<li>
<p>封装函数到某个文件之后对外暴露接口；</p>
</li>
<li>
<p>高可维护性：多个人员协同开发减少命名冲突；升级的时候只需部分模块升级；</p>
</li>
</ol>
<p>模块化规范（纸面上的东西）：</p>
<ol>
<li>
<p>CommonJS，以他为规范的产品有：NodeJS、Browserify；</p>
</li>
<li>
<p>AMD，以他为规范的产品：requireJS；</p>
</li>
<li>
<p>CMD，以他为规范产品：seaJS</p>
</li>
</ol>
<p>AMD、CMD是专门针对浏览器端的</p>
<h4 id="暴露语法">暴露语法</h4>
<p><img src="/ES6/d8a6503a4f6272acc5cbb0639992c538.png" alt=""></p>
<h5 id="分别暴露">分别暴露</h5>
<p>首先写一个js文件：</p>
<p><img src="/ES6/905c2940c3eac4ee3cc861a70d15591d.png" alt=""></p>
<p>然后引入：</p>
<p>原先我们是直接引入：</p>
<p><img src="/ES6/81ecdcc85165856692959ef2939a287c.png" alt=""></p>
<p>现在我们用模块的方式引入：</p>
<p><img src="/ES6/c93deef5b4ac152e429e4c8dc6179068.png" alt=""></p>
<p>这样可以把目标文件所有export的东西全部引过来</p>
<p>我们把引过来的m1做一个输出：</p>
<p><img src="/ES6/d5d5adfca5fe207d916655f0cbfbe108.png" alt=""></p>
<h5 id="统一暴露">统一暴露</h5>
<p><img src="/ES6/685673a374ac7091472cdab35ec4c0ac.png" alt=""></p>
<p><img src="/ES6/db3876d198a44d9009d0024881b90741.png" alt=""></p>
<h5 id="默认暴露">默认暴露</h5>
<p><img src="/ES6/69ca7d6f4b9dfa8c3c3c4356681232bd.png" alt=""></p>
<p><img src="/ES6/2a5770f11c4518de73cc31278c07b0ec.png" alt=""></p>
<p>跟上面的不太一样，这种引入方式引入的是一个名为default的Object，在这个Object里面才会有我们想要的数据：</p>
<p><img src="/ES6/26096de53b6888a4ea67d72da6484c73.png" alt=""></p>
<p>我们如果想要使用里面的方法的话就要对加一层default：</p>
<p><img src="/ES6/50cfb19be08d2d78766aa61839739e59.png" alt=""></p>
<h4 id="引入语法">引入语法</h4>
<h5 id="通用导入方式">通用导入方式</h5>
<p><img src="/ES6/3c47221a4c928627a05f7df8e87f7577.png" alt=""></p>
<h5 id="解构赋值形式">解构赋值形式</h5>
<p><img src="/ES6/5028104520850f3c96276af56956ecf6.png" alt=""></p>
<p>这里会有重名的问题：</p>
<p><img src="/ES6/718024128ba64ae7fcde267b48809434.png" alt=""></p>
<p>我们发现上图的两个school重名了，因此报错：</p>
<p><img src="/ES6/f4144d56351c51ad4c1bac99d899b1cc.png" alt=""></p>
<p>解决方法是使用别名：</p>
<p><img src="/ES6/3531dc35bc8becb6a043da949adc3011.png" alt=""></p>
<p>问题2：</p>
<p>当我们使用export default
{}的形式暴露的时候，引入时应该引default，但是不可以直接写default：</p>
<p><img src="/ES6/5aa56bf427d9dca1272ea8589d4a46f0.png" alt=""></p>
<p>这样是会报错的，应该给default一个别名：</p>
<p><img src="/ES6/146c2ed2fe0711392151baac974656e3.png" alt=""></p>
<h5 id="简便形式">简便形式</h5>
<p><img src="/ES6/cd4a00a50d1071c30a03d8221084a305.png" alt=""></p>
<p>当我们用export default
{}的形式暴露的时候，引入时可以直接写别名，如上图的m3。除了这种情况以外，别的都不能直接写别名引入。</p>
<h4 id="入口文件">入口文件</h4>
<p>除了直接在html代码中写一个script标签引入module之外，我们还可以将用于引入的代码语句写到一个入口文件里面，这里创建的入口文件是app.js</p>
<p><img src="/ES6/08942ef7123cc72e3dde9d1c76602f1f.png" alt=""></p>
<p>然后在html文件中引入该入口文件</p>
<p><img src="/ES6/8eba8ebe999c5d9d060404d640971086.png" alt=""></p>
<p>注意要在原先引入js文件的写法的基础上再写一个type=“module”</p>
<p>而且，在入口文件app.js里面，我们还可以写其他js的语句，比方说将引入的module输出：</p>
<p><img src="/ES6/eb9161867c67ac1ff9ec956f5a3ed2aa.png" alt=""></p>
<h3 id="babel对es6模块化代码转换">babel对ES6模块化代码转换</h3>
<p>在项目中由于兼容性问题以及ES6的模块化还不能对npm安装的一些模块进行导入，因此我们往往不会直接这么写：</p>
<p><img src="/ES6/af42203f33d55081dac00d46467c9dd3.png" alt=""></p>
<p>而是会通过babel做一个转换</p>
<h4 id="使用流程">使用流程</h4>
<p><img src="/ES6/536411533e02235997155446f863f74a.png" alt=""></p>
<p>安装工具 babel-cli babel-preset-env browserify(webpack);
（在正式的项目中一般用webpack打包，但是他配置项多，所以我们暂时用browserify打包）</p>
<h5 id="安装">安装</h5>
<p>初始化npm：</p>
<p><img src="/ES6/b44cc291451adeaff1573f60ec8f94d0.png" alt=""></p>
<p>之后生成：</p>
<p><img src="/ES6/d1104b68ec877a449e9bf4a349c63f48.png" alt=""></p>
<p>开始安装：</p>
<p><img src="/ES6/1f8478d82af79c0f337d8e76208ea84e.png" alt=""></p>
<p>-D是指开发依赖</p>
<h5 id="转换">转换</h5>
<p>由于上述是本地安装，因此无法直接用命令行调用安装的软件，我们可以用npx来调用：</p>
<p><img src="/ES6/11da9e3f56ec89e5f5f7e749823b91f3.png" alt=""></p>
<p><img src="/ES6/c46adfd3907ff8bf4e4e8291c53e005d.png" alt=""></p>
<p>这里src下的文件是我们的原文件，dist下面是转换后的文件。我们来看一下区别：</p>
<p>原文件：</p>
<p><img src="/ES6/2422ed732ea391599f5be444ec4fbbca.png" alt=""></p>
<p>转换后文件：</p>
<p><img src="/ES6/46d4b65e7bd546a339c2b9576ff722f7.png" alt=""></p>
<p>这里的暴露语法发生了一些变化，转换后文件的暴露语法是一些CommonJS模块化规范的语法</p>
<p><img src="/ES6/0d427be4ae567d46cd7a04ff47d896a0.png" alt=""></p>
<p>CommonJS上面有介绍过</p>
<h5 id="打包">打包</h5>
<p>如果不打包，上面转换后的js代码是不能正常运行的，因为他不识别里面的有些语法，比方说这里他就不识别require的语法：</p>
<p><img src="/ES6/1dd3eb5d6a862901a7cb07e523e1e6f3.png" alt=""></p>
<p><img src="/ES6/f20f5338c4d9c7d76ae19ad0173ff54f.png" alt=""></p>
<p>这里我们给他引入一下，执行之后的结果：</p>
<p><img src="/ES6/5995e291e8f2fee0a0833a5282c42821.png" alt=""></p>
<p>require不识别</p>
<p><img src="/ES6/4b28699b1861e2a4ceb90516c4b98a8e.png" alt=""></p>
<p>我们将转换后的文件的app.js打包到bundle.js</p>
<p><img src="/ES6/18732a39e96ff81cecbbee520a5f5a46.png" alt=""></p>
<p>这里-o的意思是output，后面应该写打包到的那个文件</p>
<p>打包好的文件：</p>
<p><img src="/ES6/4a326a5786083ef6901eb7f16f388d5f.png" alt=""></p>
<h5 id="引入">引入</h5>
<p>之后引入该bundle.js文件：</p>
<p><img src="/ES6/fcf937b93bfb34c71a849381ca80f67b.png" alt=""></p>
<p>之后就正常了：</p>
<p><img src="/ES6/d8f453bd72130163d3e7f4ee9de9a09b.png" alt=""></p>
<h5 id="如何对打包后的文件进行修改">如何对打包后的文件进行修改</h5>
<p>先修改原文件，再重新转换、打包即可</p>
<h3 id="es6导入npm包的语法">ES6导入npm包的语法</h3>
<p>import 变量名 from ‘npm包名’;</p>
<p>它的作用就相当于原先commonjs的语法：</p>
<p>const 变量名 = require(‘npm包名’);</p>
<p>之后就能用该变量名来调用引入的npm包了</p>
<h4 id="导入npm包并用npm包做出修改之后如何使用修改后的代码">导入npm包并用npm包做出修改之后如何使用修改后的代码</h4>
<p>跟上面的打包流程是一样的，先转换后打包再引入打包后的js文件最后才能使用</p>
<h2 id="npm">npm</h2>
<h3 id="全局安装">全局安装</h3>
<p>npm install xxx -g 或 npm install xxx –-global</p>
<p><img src="/ES6/84702b2c2bb134f2ff093ee2fdfcca5d.png" alt=""></p>
<h3 id="本地安装">本地安装</h3>
<p>npm install xxx 或 npm install xxx –-save-dev</p>
<p><img src="/ES6/5b095988fdfed98a4929ceafe78428eb.png" alt=""></p>
<h2 id="npx">npx</h2>
<h3 id="安装npx">安装npx</h3>
<p><img src="/ES6/975e18e92c485756465d543e5cf7ce61.png" alt=""></p>
<h3 id="调用项目安装的模块">调用项目安装的模块</h3>
<p><img src="/ES6/1af6e07f92e761798d16365f68b67204.png" alt=""></p>
<h3 id="避免全局安装模块">避免全局安装模块</h3>
<p><img src="/ES6/44989d8094a51091a4451bfa98942ab5.png" alt=""></p>
<h3 id="--no-install参数和ignore-existing参数">&ndash;no-install参数和—ignore-existing参数</h3>
<p><img src="/ES6/be58a96a0f762c7ff7843560545ef7b1.png" alt=""></p>
<h3 id="使用不同版本的node">使用不同版本的node</h3>
<p><img src="/ES6/92a883729478704adf0955b00c559ce5.png" alt=""></p>
<p><img src="/ES6/80fa961fc835184976bd4b84e3f19611.png" alt=""></p>
<h3 id="执行github源码">执行GitHub源码</h3>
<p><img src="/ES6/5e0fca2ba9e4157a295b94d1753d1bc8.png" alt=""></p>
  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>ES6</b><nav id="TableOfContents">
  <ul>
    <li><a href="#es6">ES6</a>
      <ul>
        <li><a href="#let">let</a></li>
        <li><a href="#const">const</a></li>
        <li><a href="#letconstvar的区别">let、const、var的区别</a></li>
        <li><a href="#解构赋值">解构赋值</a></li>
        <li><a href="#箭头函数">箭头函数</a></li>
        <li><a href="#rest剩余参数">rest（剩余参数）</a></li>
        <li><a href="#array的扩展方法扩展运算符展开语法">Array的扩展方法，扩展运算符（展开语法）</a></li>
        <li><a href="#string的扩展方法">String的扩展方法</a></li>
        <li><a href="#set">Set</a></li>
        <li><a href="#map">Map</a></li>
        <li><a href="#对象简化写法">对象简化写法</a></li>
        <li><a href="#es6允许给函数参数赋值初始值">ES6允许给函数参数赋值初始值</a></li>
        <li><a href="#es6允许参数使用解构进行赋值">ES6允许参数使用解构进行赋值</a></li>
        <li><a href="#symbol基本使用">Symbol基本使用</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
        <li><a href="#迭代器iterator">迭代器(iterator)</a></li>
        <li><a href="#生成器yield">生成器（yield）</a></li>
        <li><a href="#promise">Promise</a></li>
        <li><a href="#class">class</a></li>
        <li><a href="#数值扩展">数值扩展</a></li>
        <li><a href="#对象方法扩展">对象方法扩展</a></li>
        <li><a href="#模块化">模块化</a></li>
        <li><a href="#babel对es6模块化代码转换">babel对ES6模块化代码转换</a></li>
        <li><a href="#es6导入npm包的语法">ES6导入npm包的语法</a></li>
      </ul>
    </li>
    <li><a href="#npm">npm</a>
      <ul>
        <li><a href="#全局安装">全局安装</a></li>
        <li><a href="#本地安装">本地安装</a></li>
      </ul>
    </li>
    <li><a href="#npx">npx</a>
      <ul>
        <li><a href="#安装npx">安装npx</a></li>
        <li><a href="#调用项目安装的模块">调用项目安装的模块</a></li>
        <li><a href="#避免全局安装模块">避免全局安装模块</a></li>
        <li><a href="#--no-install参数和ignore-existing参数">&ndash;no-install参数和—ignore-existing参数</a></li>
        <li><a href="#使用不同版本的node">使用不同版本的node</a></li>
        <li><a href="#执行github源码">执行GitHub源码</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    ©QYF Just for record 2018-2019 &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
