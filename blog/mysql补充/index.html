<!DOCTYPE html>
<html>
  <head>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  MySQL补充 &ndash; Learning Records

    </title>
    
    <meta content="MySQL" name="keywords">
    
    
    <meta name="description" property="og:description" content="对于MySQL的一些额外的补充
|Just for record">
    

    <meta name="apple-mobile-web-app-title" content="Learning Records">
    
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    <meta name="twitter:title" content="MySQL补充 | Learning Records">
    <meta name="twitter:description" content="对于MySQL的一些额外的补充|Just for record">
    <meta name="twitter:image" content="https://pippichi.github.iotwitter-card.png">
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="stylesheet" href="/assets/custom_style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://pippichi.github.io">
    Learning Records
  </a>

  
  
  <div class="UnderlineNav-body">
    
    
    
    <a class="UnderlineNav-item" href="/blog/">
      
      <span>Home</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item" href="/">
      
      <span>PDF/CODE</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item" href="/about/">
      
      <span>About</span>
    </a>
    
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">MySQL补充</div>
  </div>
  <div class="Subhead-description">
    


<a href='/categories/additional' class="muted-link">
  <span class="Label Label--gray-darker">Additional</span>
</a>



<a href='/tags/mysql' class="muted-link">
  <span class="Label Label--gray">MySQL</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2020-12-29. Published at: 2020-12-29.">
        
          Published: 2020-12-29
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <p>对于MySQL的一些额外的补充</p>
<h2 id="使用yum安装mysql8">使用yum安装MySQL8</h2>
<p>先使用yum list installed |grep mysql* 来查看是否有残留mysql</p>
<p>如果有使用yum remove mysql* 删除所有残留mysql</p>
<p>接下来删除 /var/lib/mysql下的所有残留文件</p>
<p>接下来依次执行命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">wget</span> <span class="o">-</span><span class="n">i</span> <span class="o">-</span><span class="n">c</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">dev</span><span class="p">.</span><span class="n">mysql</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">get</span><span class="o">/</span><span class="n">mysql80</span><span class="o">-</span><span class="n">community</span><span class="o">-</span><span class="k">release</span><span class="o">-</span><span class="n">el7</span><span class="o">-</span><span class="mi">3</span><span class="p">.</span><span class="n">noarch</span><span class="p">.</span><span class="n">rpm</span>
<span class="n">yum</span> <span class="o">-</span><span class="n">y</span> <span class="n">install</span> <span class="n">mysql80</span><span class="o">-</span><span class="n">community</span><span class="o">-</span><span class="k">release</span><span class="o">-</span><span class="n">el7</span><span class="o">-</span><span class="mi">3</span><span class="p">.</span><span class="n">noarch</span><span class="p">.</span><span class="n">rpm</span>
<span class="n">yum</span> <span class="o">-</span><span class="n">y</span> <span class="n">install</span> <span class="n">mysql</span><span class="o">-</span><span class="n">community</span><span class="o">-</span><span class="n">server</span>
<span class="n">systemctl</span> <span class="n">start</span> <span class="n">mysqld</span><span class="p">.</span><span class="n">service</span>
<span class="n">systemctl</span> <span class="n">status</span>  <span class="n">mysqld</span><span class="p">.</span><span class="n">service</span>
</code></pre></div><p>不出意外的话这个时候应该就好了</p>
<p>查看systemctl中所有enable的项，查看mysql服务是否开机自启：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">systemctl</span> <span class="n">list</span><span class="o">-</span><span class="n">unit</span><span class="o">-</span><span class="n">files</span><span class="o">|</span><span class="n">grep</span> <span class="n">enabled</span>
</code></pre></div><p>接下来修改密码：</p>
<p>运行命令查看初始化的时候自动生成的密码：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">grep</span> <span class="s2">&#34;password&#34;</span> <span class="o">/</span><span class="n">var</span><span class="o">/</span><span class="n">log</span><span class="o">/</span><span class="n">mysqld</span><span class="p">.</span><span class="n">log</span>
</code></pre></div><p>在靠近最后一行的位置我们会找到生成的密码：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="p">...</span><span class="n">A</span> <span class="n">temporary</span> <span class="n">password</span> <span class="k">is</span> <span class="n">generated</span> <span class="k">for</span> <span class="n">root</span><span class="o">@</span><span class="n">localhost</span><span class="p">:</span> <span class="n">xxx</span>
</code></pre></div><p>得到密码之后我们就能登录MySQL了</p>
<p>首次登录啥都不能干，只能重置密码，这个时候可能会遇到设置密码过于简单系统无法通过的情况，暂时没办法，只能先设置一个难度级别高的密码</p>
<p>设置完密码之后就可以去修改设置密码的级别了</p>
<p>执行命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;validate_password%&#39;</span><span class="p">;</span>
</code></pre></div><p>我们会看到对于密码设置的诸多限制，有：</p>
<ul>
<li>validate_password_length</li>
<li>validate_password_number_count</li>
<li>validate_password.policy</li>
<li>validate_password.check_user_name</li>
<li>validate_password_mixed_case_count</li>
<li>validate_password_special_char_count</li>
<li>&hellip;</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-tex" data-lang="tex">密码的长度是由validate<span class="nb">_</span>password<span class="nb">_</span>length决定的，而validate<span class="nb">_</span>password<span class="nb">_</span>length的计算公式是：
validate<span class="nb">_</span>password<span class="nb">_</span>length = validate<span class="nb">_</span>password<span class="nb">_</span>number<span class="nb">_</span>count + validate<span class="nb">_</span>password<span class="nb">_</span>special<span class="nb">_</span>char<span class="nb">_</span>count + (2 * validate<span class="nb">_</span>password<span class="nb">_</span>mixed<span class="nb">_</span>case<span class="nb">_</span>count)
</code></pre></div><p>这里我们举个例子改两个参数：</p>
<div class="highlight"><pre class="chroma"><code class="language-tex" data-lang="tex">set global validate<span class="nb">_</span>password.policy=0;
set global validate<span class="nb">_</span>password.length=1;
</code></pre></div><p>现在就能将刚才设置的很难的密码改成简单的了：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">alter</span> <span class="k">user</span> <span class="s1">&#39;root&#39;</span><span class="o">@</span><span class="s1">&#39;localhost&#39;</span> <span class="k">identified</span> <span class="k">by</span> <span class="s1">&#39;xxx&#39;</span><span class="p">;</span>
</code></pre></div><p>最后一步，设置允许远程连接</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">grant</span> <span class="k">all</span> <span class="k">privileges</span> <span class="k">on</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">to</span> <span class="s1">&#39;root&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span> <span class="k">identified</span> <span class="k">by</span> <span class="s1">&#39;password&#39;</span><span class="p">;</span>  <span class="o">//</span> <span class="err">这里可能会提示一个语法错误。有人说是</span><span class="n">mysql8的分配权限不能带密码隐式创建账号了</span><span class="err">，要先创建账号再设置权限。也有的说</span><span class="mi">8</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">11</span><span class="err">之后移除了</span><span class="n">grant</span> <span class="err">添加用户的功能。</span>
</code></pre></div><p>那我们试试下面这种方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="err">创建用户：</span><span class="k">CREATE</span> <span class="k">USER</span> <span class="s1">&#39;root&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span> <span class="k">IDENTIFIED</span> <span class="k">BY</span> <span class="s1">&#39;xxx&#39;</span><span class="p">;</span>
<span class="err">允许远程连接：</span><span class="k">GRANT</span> <span class="k">ALL</span> <span class="k">ON</span> <span class="o">*</span><span class="p">.</span><span class="o">*</span> <span class="k">TO</span> <span class="s1">&#39;root&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span><span class="p">;</span>
<span class="err">经过测试，使用</span> <span class="k">update</span> <span class="k">user</span> <span class="kt">set</span> <span class="n">host</span> <span class="o">=</span> <span class="s1">&#39;%&#39;</span>  <span class="k">where</span> <span class="k">user</span> <span class="o">=</span> <span class="s1">&#39;root&#39;</span><span class="p">;</span> <span class="err">也可以修改</span>
</code></pre></div><p>如果使用客户端连接提示了plugin caching_sha2_password错误，这是因为MySQL8.0的密码策略默认为caching_sha2_password</p>
<p>使用命令修改策略：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">USER</span> <span class="s1">&#39;root&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span> <span class="k">IDENTIFIED</span> <span class="k">WITH</span> <span class="n">mysql_native_password</span> <span class="k">BY</span> <span class="s1">&#39;xxx&#39;</span><span class="p">;</span> 
</code></pre></div><p>最后查看我们创建或修改的用户：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="n">host</span><span class="p">,</span> <span class="k">user</span><span class="p">,</span> <span class="n">plugin</span> <span class="k">from</span> <span class="k">user</span><span class="p">;</span>
</code></pre></div><p>然后关闭防火墙，测试连接成功！</p>
<h2 id="collate">COLLATE</h2>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">table1</span><span class="o">`</span> <span class="p">(</span>
    <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="kt">bigint</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="k">unsigned</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="o">`</span><span class="n">field1</span><span class="o">`</span> <span class="kt">text</span> <span class="k">COLLATE</span> <span class="n">utf8_unicode_ci</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="n">COMMENT</span> <span class="s1">&#39;字段1&#39;</span><span class="p">,</span>
    <span class="o">`</span><span class="n">field2</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span> <span class="k">COLLATE</span> <span class="n">utf8_unicode_ci</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="n">COMMENT</span> <span class="s1">&#39;字段2&#39;</span><span class="p">,</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="kp">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="k">COLLATE</span><span class="o">=</span><span class="n">utf8_unicode_ci</span><span class="p">;</span>
</code></pre></div><h3 id="collate的作用">COLLATE的作用</h3>
<p>所谓utf8_unicode_ci，其实是用来排序的规则。对于mysql中那些字符类型的列，如VARCHAR，CHAR，TEXT类型的列，都需要有一个COLLATE类型来告知mysql如何对该列进行排序和比较。简而言之，COLLATE会影响到ORDER BY语句的顺序，会影响到WHERE条件中大于小于号筛选出来的结果，会影响DISTINCT、GROUP BY、HAVING语句的查询结果。另外，mysql建索引的时候，如果索引列是字符类型，也会影响索引创建，只不过这种影响我们感知不到。总之，凡是涉及到字符类型比较或排序的地方，都会和COLLATE有关。</p>
<h3 id="各种collate的区别">各种COLLATE的区别</h3>
<p>COLLATE通常是和数据编码（CHARSET）相关的，一般来说每种CHARSET都有多种它所支持的COLLATE，并且每种CHARSET都指定一种COLLATE为默认值。例如Latin1编码的默认COLLATE为latin1_swedish_ci，GBK编码的默认COLLATE为gbk_chinese_ci，utf8mb4编码的默认值为utf8mb4_general_ci。</p>
<p><!-- raw HTML omitted -->这里顺便讲个题外话，mysql中有utf8和utf8mb4两种编码，在mysql中请大家忘记utf8，永远使用utf8mb4。这是mysql的一个遗留问题，mysql中的utf8最多只能支持3bytes长度的字符编码，对于一些需要占据4bytes的文字，mysql的utf8就不支持了，要使用utf8mb4才行。<!-- raw HTML omitted --></p>
<p>很多COLLATE都带有<!-- raw HTML omitted -->_ci<!-- raw HTML omitted -->字样，这是Case Insensitive的缩写，即大小写无关，也就是说&quot;A&quot;和&quot;a&quot;在排序和比较的时候是一视同仁的。selection * from table1 where field1=&ldquo;a&quot;同样可以把field1为&quot;A&quot;的值选出来。与此同时，对于那些<!-- raw HTML omitted -->_cs<!-- raw HTML omitted -->后缀的COLLATE，则是Case Sensitive，即大小写敏感的。</p>
<h3 id="使用show-collation查看mysql支持的所有collate">使用SHOW COLLATION查看MySQL支持的所有COLLATE</h3>
<p>在mysql中使用show collation指令可以查看到mysql所支持的所有COLLATE。以utf8mb4为例，该编码所支持的所有COLLATE如下图所示：</p>
<p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210321151555101.png" alt="image-20210321151555101"></p>
<p>图中我们能看到很多国家的语言自己的排序规则。在国内比较常用的是utf8mb4_general_ci（默认）、utf8mb4_unicode_ci、utf8mb4_bin这三个。我们来探究一下这三个的区别：</p>
<p>首先utf8mb4_bin的比较方法其实就是直接将所有字符看作二进制串，然后从最高位往最低位比对。所以很显然它是区分大小写的。</p>
<p>而utf8mb4_unicode_ci和utf8mb4_general_ci对于中文和英文来说，其实是没有任何区别的。对于我们开发的国内使用的系统来说，随便选哪个都行。只是对于某些西方国家的字母来说，utf8mb4_unicode_ci会比utf8mb4_general_ci更符合他们的语言习惯一些，general是mysql一个比较老的标准了。例如，德语字母“ß”，在utf8mb4_unicode_ci中是等价于&quot;ss&quot;两个字母的（这是符合德国人习惯的做法），而在utf8mb4_general_ci中，它却和字母“s”等价。不过，这两种编码的那些微小的区别，对于正常的开发来说，很难感知到。本身我们也很少直接用文字字段去排序，退一步说，即使这个字母排错了一两个，真的能给系统带来灾难性后果么？从网上找的各种帖子讨论来说，更多人推荐使用utf8mb4_unicode_ci，但是对于使用了默认值的系统，也并没有非常排斥，并不认为有什么大问题。</p>
<p><!-- raw HTML omitted -->结论：推荐使用utf8mb4_unicode_ci，对于已经用了utf8mb4_general_ci的系统，也没有必要花时间改造。<!-- raw HTML omitted --></p>
<p>另外需要注意的一点是，从mysql 8.0开始，mysql默认的CHARSET已经不再是Latin1了，改为了utf8mb4，并且默认的COLLATE也改为了utf8mb4_0900_ai_ci。utf8mb4_0900_ai_ci大体上就是unicode的进一步细分，0900指代unicode比较算法的编号（ Unicode Collation Algorithm version），ai表示accent insensitive（发音无关），例如e, è, é, ê 和 ë是一视同仁的。</p>
<h3 id="collate设置级别及其优先级">COLLATE设置级别及其优先级</h3>
<p>设置COLLATE可以在实例级别、库级别、表级别、列级别、以及SQL指定。实例级别的COLLATE设置就是mysql配置文件或启动指令中的collation_connection系统变量。</p>
<p>库级别设置COLLATE的语句如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">DATABASE</span> <span class="o">&lt;</span><span class="n">db_name</span><span class="o">&gt;</span> <span class="k">DEFAULT</span> <span class="k">CHARACTER</span> <span class="kt">SET</span> <span class="n">utf8mb4</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_unicode_ci</span><span class="p">;</span>
</code></pre></div><p>如果库级别没有设置CHARSET和COLLATE，则库级别默认的CHARSET和COLLATE使用实例级别的设置。在mysql8.0以下版本中，你如果什么都不修改，默认的CHARSET是Latin1，默认的COLLATE是latin1_swedish_ci。从mysql8.0开始，默认的CHARSET已经改为了utf8mb4，默认的COLLATE改为了utf8mb4_0900_ai_ci。</p>
<p>表级别的COLLATE设置，则是在CREATE TABLE的时候加上相关设置语句，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">(</span>
<span class="p">...</span>
<span class="p">)</span> <span class="kp">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span> <span class="k">COLLATE</span><span class="o">=</span><span class="n">utf8mb4_unicode_ci</span><span class="p">;</span>
</code></pre></div><p>如果表级别没有设置CHARSET和COLLATE，则表级别会继承库级别的CHARSET与COLLATE。</p>
<p>列级别的设置，则在CREATE TABLE中声明列的时候指定，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="p">(</span>
<span class="o">`</span><span class="n">field1</span><span class="o">`</span> <span class="kt">VARCHAR</span><span class="err">（</span><span class="mi">64</span><span class="err">）</span> <span class="k">CHARACTER</span> <span class="kt">SET</span> <span class="n">utf8mb4</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span>
<span class="p">)...</span>
</code></pre></div><p>如果列级别没有设置CHARSET和COLATE，则列级别会继承表级别的CHARSET与COLLATE。</p>
<p>最后，你也可以在写SQL查询的时候显示声明COLLATE来覆盖任何库表列的COLLATE设置，不太常用，了解即可：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">field1</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_general_ci</span> <span class="k">FROM</span> <span class="n">table1</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="n">field1</span><span class="p">,</span> <span class="n">field2</span> <span class="k">FROM</span> <span class="n">table1</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">field1</span> <span class="k">COLLATE</span> <span class="n">utf8mb4_unicode_ci</span><span class="p">;</span>
</code></pre></div><p>如果全都显示设置了，那么优先级顺序是 :</p>
<p><!-- raw HTML omitted -->SQL语句 &gt; 列级别设置 &gt; 表级别设置 &gt; 库级别设置 &gt; 实例级别设置<!-- raw HTML omitted --></p>
<p>也就是说列上所指定的COLLATE可以覆盖表上指定的COLLATE，表上指定的COLLATE可以覆盖库级别的COLLATE。如果没有指定，则继承下一级的设置。即列上面没有指定COLLATE，则该列的COLLATE和表上设置的一样。</p>
<p>注意：在系统设计中，我们还是要尽量避免让系统严重依赖中文字段的排序结果，在mysql的查询中也应该尽量避免使用中文做查询条件。</p>
<h2 id="check检查表的状况查看表是否损坏">CHECK检查表的状况（查看表是否损坏）</h2>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CHECK</span> <span class="k">TABLE</span> <span class="n">t1</span><span class="p">;</span>
</code></pre></div><p>返回结果：</p>
<table>
<thead>
<tr>
<th>Table表名称</th>
<th>Op进行修复</th>
<th>Msg_type状态、错误、信息或警告之一</th>
<th>Msg_text消息</th>
</tr>
</thead>
<tbody>
<tr>
<td>db1.t1</td>
<td>check</td>
<td>status</td>
<td>OK</td>
</tr>
</tbody>
</table>
<h2 id="analyze关键字">ANALYZE关键字</h2>
<p>MySQL 的Optimizer（优化元件）在优化SQL语句时，首先需要收集一些相关信息，其中就包括表的cardinality（可以翻译为“散列程度”），它表示某个索引对应的列包含多少个不同的值——如果cardinality大大少于数据的实际散列程度，那么索引就基本失效了。</p>
<p>我们可以使用SHOW INDEX语句来查看索引的散列程度：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SHOW</span> <span class="k">INDEX</span> <span class="k">FROM</span> <span class="n">PLAYERS</span><span class="p">;</span>
</code></pre></div><p>假设得到结果：</p>
<table>
<thead>
<tr>
<th>TABLE</th>
<th>KEY_NAME</th>
<th>COLUMN_NAME</th>
<th>CARDINALITY</th>
</tr>
</thead>
<tbody>
<tr>
<td>PLAYERS</td>
<td>PRIMARY</td>
<td>PLAYERNO</td>
<td>14</td>
</tr>
</tbody>
</table>
<p>如果此时PLAYER表中不同的PLAYERNO数量远多于14，索引基本失效</p>
<p>通过ANALYZE TABLE语句来修复索引：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ANALYZE</span> <span class="k">TABLE</span> <span class="n">PLAYERS</span><span class="p">;</span>
<span class="k">SHOW</span> <span class="k">INDEX</span> <span class="k">FROM</span> <span class="n">PLAYERS</span><span class="p">;</span>
</code></pre></div><p>假设得到结果：</p>
<table>
<thead>
<tr>
<th>TABLE</th>
<th>KEY_NAME</th>
<th>COLUMN_NAME</th>
<th>CARDINALITY</th>
</tr>
</thead>
<tbody>
<tr>
<td>PLAYERS</td>
<td>PRIMARY</td>
<td>PLAYERNO</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>此时索引已经修复，查询效率大大提高</p>
<p>需要注意的是，如果开启了binlog，那么ANALYZE TABLE的结果也会写入binlog，我们可以在ANALYZE和TABLE之间添加关键字LOCAL取消写入：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ANALYZE</span> <span class="n">LOCAL</span> <span class="k">TABLE</span> <span class="n">tbl_name</span><span class="p">;</span>
</code></pre></div><h2 id="repair-table修复表">repair table修复表★</h2>
<p>REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE  tbl_name[,tbl_name] &hellip; [QUICK] [EXTENDED] [USE_FRM]</p>
<p>REPAIR TABLE用于修复被破坏的表。默认情况下，REPAIR TABLE与myisamchk &ndash;recovertbl_name具有相同的效果。REPAIR TABLE对MyISAM和ARCHIVE表起作用。</p>
<p>通常，您基本上不必运行此语句。但是，如果灾难发生，REPAIR TABLE很有可能从MyISAM表中找回所有数据。如果您的表经常被破坏，您应该尽力找到原因，以避免使用REPAIR TABLE。</p>
<p>本语句会返回表：</p>
<table>
<thead>
<tr>
<th>Table表名称</th>
<th>Op进行修复</th>
<th>Msg_type状态、错误、信息或警告之一</th>
<th>Msg_text消息</th>
</tr>
</thead>
<tbody>
<tr>
<td>..</td>
<td>..</td>
<td>..</td>
<td>..</td>
</tr>
</tbody>
</table>
<p>对于每个被修复的表，REPAIR TABLE语句会产生多行的信息。上一行含有一个Msg_type状态值。Msg_test通常应为OK。如果您没有得到OK，您应该尝试使用myisamchk &ndash;safe-recover修复表，因为REPAIR TABLE尚不会执行所有的myisamchk选项。</p>
<p>QUICK、EXTENDED、USE_FRM三个参数的区别：</p>
<ul>
<li>
<p>QUICK</p>
<p>如果给定了QUICK，则REPAIR TABLE会尝试只修复索引树。这种类型的修复与使用myisamchk &ndash;recover &ndash;quick相似。</p>
</li>
<li>
<p>EXTENDED</p>
<p>如果您使用EXTENDED，则MySQL会一行一行地创建索引行，代替使用分类一次创建一个索引。这种类型的修复与使用myisamchk &ndash;safe-recover相似。</p>
</li>
<li>
<p>USE_FRM</p>
<p>对于REPAIR TABLE，还有一种USE_FRM模式可以利用。如果.MYI索引文件缺失或标题被破坏，则使用此模式。在这种模式下，MySQL可以使用来自.frm文件重新创建.MYI文件。这种修复不能使用myisamchk来完成。注释：只能在您不能使用常规REPAIR模式是，才能使用此模式。.MYI标题包含重要的表元数据（特别是，当前的AUTO_INCREMENT值和Delete链接）。这些元数据在REPAIR&hellip;USE_FRM中丢失。如果表被压缩，则不能使用USE_FRM。因为本信息也存储在.MYI文件中。</p>
</li>
</ul>
<p>NO_WRITE_TO_BINLOG（别名LOCAL）的作用：</p>
<p>REPAIR TABLE语句被写入二进制日志中，除非使用了自选的NO_WRITE_TO_BINLOG关键词（或其别名LOCAL）。</p>
<p><strong>警告</strong>：如果在REPAIR TABLE运行过程中，服务器停机，则在重新启动之后，在执行其它操作之前，您必须立刻对表再执行一个REPAIR TABLE语句。（通过制作一个备份来启动是一个好办法。）再最不利情况下，您可以有一个新的干净的索引文件，不含有关数据文件的信息。然后，您执行的下一个操作会覆盖数据文件。这很少发生，但是是有可能的。</p>
<p>mysql repair table-Can’t open file: ‘[Table]mytable.MYI’.</p>
<p>也许很多人遇到过类似Can’t open file: ‘[Table]mytable.MYI’ 这样的错误信息,却不知道怎么解决他,下面我们做个介绍:</p>
<p>多数情况下,数据库被破坏只是指索引文件受到了破坏,真正的数据被破坏掉的情况非常少。大多数形式的数据库破坏的的修复相当简单。</p>
<p>下面讲的方法只对MyISAM格式的表有效。其他类型的损坏需要从备份中恢复。</p>
<ul>
<li>
<p>REPAIR TABLE SQL statement(mysql服务必须处于运行状态)。</p>
<p>语法:repair table 表名 [选项]</p>
<p>选项如下:
　　　　QUICK 用在数据表还没被修改的情况下,速度最快
　　　　EXTENDED 试图去恢复每个数据行,会产生一些垃圾数据行,万般无奈的情况下用
　　　　USE_FRM 用在.MYI文件丢失或者头部受到破坏的情况下。利用.frm的定义来重建索引</p>
<p>　　　　多数情况下,简单得用”repair table tablename”不加选项就可以搞定问题。但是当.MYI文件丢失或者头部受到破坏时,这样的方式不管用,例如:</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Op</th>
<th>Msg_type</th>
<th>Msg_text</th>
</tr>
</thead>
<tbody>
<tr>
<td>sports_results.mytable</td>
<td>repair</td>
<td>error</td>
<td>Can’t open file: ‘[Table]mytable.MYI’(errno:2)</td>
</tr>
</tbody>
</table>
<p>修复失败的原因是索引文件丢失或者其头部遭到了破坏,为了利用相关定义文件来修复,需要用USE_FRM选项:</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"> <span class="n">REPAIR</span> <span class="k">TABLE</span> <span class="n">mytable</span> <span class="n">USE_FRM</span><span class="p">;</span> 
</code></pre></div><p>操作之后我们可以看到：</p>
<table>
<thead>
<tr>
<th>Table</th>
<th>Op</th>
<th>Msg_type</th>
<th>Msg_text</th>
</tr>
</thead>
<tbody>
<tr>
<td>sports_results.mytable</td>
<td>repair</td>
<td>warning</td>
<td>Number of rows changed from 0 to 2</td>
</tr>
<tr>
<td>sports_results.mytable</td>
<td>repair</td>
<td>status</td>
<td>OK</td>
</tr>
</tbody>
</table>
<p>我们可以看到Msg_test表项的输出信息”ok”,表名已经成功修复受损表。</p>
</li>
<li>
<p>命令mysqlcheck(mysql服务可以处于运行状态)。</p>
<pre><code>语法:mysqlcheck -r 数据库名 表名 -uuser -ppass
  
　　Command: %mysqlcheck -r sports_results mytable -uuser -ppwd
  
　　Result:　　 sports_results.mytable OK
　　
  
　　利用mysqlcheck可以一次性修复多个表。只要在数据库名后列出相应表名即可(用空格隔开)。或者数据库名后不加表名,将会修复数据库中的所有表,例如:
  
　　Command: %mysqlcheck -r sports_results mytable events -uuser -ppwd
  
　　Result:　　 sports_results.mytable OK
　　Result:　　 sports_results.events OK
  
　　Command: %mysqlcheck -r sports_results -uuser -ppwd
　　　　
  
　　Result:　　 sports_results.mytable OK
　　Result:　　 sports_results.events OK
</code></pre></li>
<li>
<p>命令myisamchk(必须停掉mysql服务,或者所操作的表处于不活动状态)。</p>
<pre><code>用这种方式时,mysql服务必须停掉,或者所操作的表处于不活动状态(选项skip-external-locking没被使用)。记着一定要在相关.MYI文件的路径下或者自己定义其路径。
　　
　　语法:myisamchk [选项] [表名]
　　
　　下面是其选项和描述
　　　　–backup, -B 在进行修复前作相关表得备份
　　　　–correct-checksum 纠正校验和
　　　　–data-file-length=#, -D # 重建表时,指定数据文件得最大长度
　　　　–extend-check, -e 试图去恢复每个数据行,会产生一些垃圾数据行,万般无奈的情况下用
　　　　–force, -f 当遇到文件名相同的.TMD文件时,将其覆盖掉。
　　　　keys-used=#, -k # 指定所用的keys可加快处理速度,每个二进制位代表一个key.第一个key为0
　　　　–recover, -r 最常用的选项,大多数破坏都可以通过它来修复。
  
　　　　　　　　如果你的内存足够大,可以增大参数sort_buffer_size的值来加快恢复的速度。但是遇到唯一键由于破坏而不唯一的表时,这种方式不管用。
  
　　　　–safe-recover -o 最彻底的修复方式,但是比-r方式慢,一般在-r修复失败后才使用。
  
　　　　　　　　这种方式读出所有的行,并以行为基础来重建索引。它的硬盘空间需求比-r方式稍微小一点,因为它没创建分类缓存。你可以增加key_buffer_size的值来加快修复的速度。
　　　　–sort-recover, -n mysql用它类分类索引,尽管结果是临时文件会非常大
　　　　–character-sets-dir=… 包含字符集设置的目录
　　　　–set-character-set=name 为索引定义一个新的字符集
　　　　–tmpdir=path, -t 如果你不想用环境变量TMPDIR的值的话,可以自定义临时文件的存放位置
　　　　–quick, -q 最快的修复方式,当数据文件没有被修改时用,当存在多键时,第二个-q将会修改 数据文件
　　　　–unpack, -u 解开被myisampack打包的文件
  
　　　　myisamchk应用的一个例子
  
　　　　　　% myisamchk -r mytable
        recovering (with keycache) MyISAM-table ‘mytable.MYI’
　　　　　　Data records: 0
</code></pre></li>
</ul>
<p>在修复表的时候，最好先作一下备份。所以你需要两倍于原始表大小的硬盘空间。请确保在进行修复前你的硬盘空间还没有用完。</p>
<h2 id="innodb数据损坏修复">InnoDB数据损坏修复</h2>
<p>InnoDB是带有事务的存储引擎，并且其内部机制会自动修复大部分数据损坏错误，它会在服务器启动时进行修复。
不过，有时候数据损坏得很严重并且InnoDB无法在没有用户交互的情况下完成修复，在这种情况下，有&ndash;innodb_force_recovery启动选项（当然也可以在/etc/my.cnf中配置innodb_force_recovery）。该选项可以设置0~6(0 不强制修复 1是最低级别 6最高级别)：</p>
<ul>
<li>1：忽略检查到的corrupt页</li>
<li>2：阻止主线程的运行，如主线程需要执行full purge操作，则会导致crash</li>
<li>3：不执行事务回滚操作</li>
<li>4：不执行插入缓存的合并操作</li>
<li>5：不查看重做日志，InnoDB存储引擎会将未提交的事务视为已提交</li>
<li>6：不执行前滚的操作</li>
</ul>
<p>如果发生损坏，可以从1开始尝试修复，直到可以启动服务器并且可以访问有问题的表为止。
启动后使用select into outfile将表转储到文件中，然后使用drop和create命令重新创建表，最后用&ndash;innodb_force_recovery=0重新启动服务器，然后加载文件数据。
当需要在&ndash;innodb_force_recovery选项是正数的情况下修复数据库时，错误日志通常会有明确的提示信息。</p>
<p>当设置innodb_force_recovery大于0之后，可以对表进行select、create、drop操作，但insert、update、delete这类操作是不允许的。所以在最后表修复完成之后，不要忘了把innodb_force_recovery设置为0或注释掉</p>
<p>如果仍不能启动，可以使用备份来还原数据库，推荐先物理备份下/var/lib/mysql，之后可以试着删除ib_logfile0、ib_logfile1和ibdata1文件，然后启动mysql服务来还原</p>
<h2 id="数据备份">数据备份</h2>
<p>参考：https://www.cnblogs.com/gered/p/10410978.html（MySQL备份（数据导出与导入））、https://blog.csdn.net/u012436346/article/details/86570902（使用mysqldump导入与导出数据）</p>
<p>注意，mysqldump的时候可能会报错：</p>
<pre><code>mysqldump: Couldn't execute 'SELECT COLUMN_NAME,JSON_EXTRACT(HISTOGRAM, '$.&quot;number-of-buckets-specified&quot;')ROM information_schema.COLUMN_STATISTICS WHERE SCHEMA_NAME = 'store' AND TABLE_NAME = 't_address';': Unknown table 'column_statistics' in information_schema (1109)
</code></pre><p>原因是早期版本MySQL的<code>information_schema</code>数据库中没有名为<code>COLUMN_STATISTICS</code>的数据表，而新版的mysqldump对于<code>--column-statistics</code>参数默认是启动的（<code>--column-statistics=1</code>），我们可以通过<code>--column-statistics=0</code>来禁用他：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ mysqldump --column-statistics<span class="o">=</span><span class="m">0</span> -h x.x.x.x -P xxxx -u xxx -p xxx &gt; xxx.sql
</code></pre></div><h2 id="optimize关键字">OPTIMIZE关键字</h2>
<p>MySQL执行命令delete语句时，如果包括where条件，并不会真正的把数据从表中删除，而是将数据转换成了碎片，通过下面的命令可以查看表中的碎片数量和索引等信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">show</span> <span class="k">table</span> <span class="n">status</span> <span class="k">like</span> <span class="n">tbl_name</span><span class="p">;</span>
</code></pre></div><p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210410230027928.png" alt="image-20210410230027928"></p>
<p>查询结果中：</p>
<p>Index_length 代表索引的数量</p>
<p>Data_free 代表碎片数量</p>
<p>然后执行下面命令进行优化整理：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">OPTIMIZE</span> <span class="k">TABLE</span> <span class="n">tbl_name</span><span class="p">;</span>
</code></pre></div><p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210410230115306.png" alt="image-20210410230115306"></p>
<p>需要注意的是，如果开启了binlog，那么OPTIMIZE TABLE的结果也会写入binlog，我们可以在OPTIMIZE和TABLE之间添加关键字LOCAL取消写入：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">OPTIMIZE</span> <span class="n">LOCAL</span> <span class="k">TABLE</span> <span class="n">tbl_name</span><span class="p">;</span>
</code></pre></div><p>OPTIMIZE TABLE只对MyISAM, BDB和InnoDB表起作用。</p>
<p>注意：在OPTIMIZE TABLE运行过程中，MySQL会锁定表。</p>
<h2 id="duplicate关键字">DUPLICATE关键字</h2>
<p>在日常业务开发中经常有这样一个场景，首先创建一条记录，然后插入到数据库，如果数据库已经存在同一主键的记录，执行update操作；否则，执行insert操作。这个操作可以在业务层做，也可以在数据库层面做。业务层一般做法是先查询，如果不存在就插入，如果存在就更新；但是查询和插入不是原子性操作，在并发量比较高的时候，可能两个线程都查询不到某个记录，所以会执行两次插入，其中一条必然会因为唯一性约束冲突而失败。数据库层mysql中INSERT &hellip; ON DUPLICATE KEY UPDATE就可以做这个事情，<strong>并且是原子性操作</strong>。</p>
<p><strong>INSERT &hellip; ON DUPLICATE KEY UPDATE命令</strong></p>
<ul>
<li>
<p>单条记录下使用</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="nf">t1</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">ON</span> <span class="n">DUPLICATE</span> <span class="k">KEY</span> <span class="k">UPDATE</span> <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>如上sql假如t1表的主键或者UNIQUE 索引是a，那么当执行sql的时候，如果数据库里面已经存在a=1的记录则更新这条记录的c字段的值为原来值+1，然后返回值为2；如果不存在则插入记录a=1,b=2,c=3，然后返回值为1。</p>
<p>**如果insert语句中同时出现UNIQUE索引和PRIMARY KEY，则以后者为准。**ON DUPLICATE KEY UPDATE后面可以放多个字段，用英文逗号分割。</p>
</li>
<li>
<p>多条记录下使用</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="nf">t1</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span> <span class="k">ON</span> <span class="n">DUPLICATE</span> <span class="k">KEY</span> <span class="k">UPDATE</span> <span class="n">c</span> <span class="o">=</span> <span class="k">VALUES</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">b</span> <span class="o">=</span> <span class="k">VALUES</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="c1">-- VALUES() 是针对同时插入多条记录时获取正确的待设置值 --
</span></code></pre></div></li>
</ul>
<p>注意：<code>case when、duplicate key update、for循环</code>更新或插入数据时，<code>duplicate key update</code>是最快的，但是一般大公司都禁用，公司一般都禁止使用<code>replace into和INSERT INTO … ON DUPLICATE KEY UPDATE</code>，这种sql有可能会造成数据丢失和主从上表的自增id值不一致。而且用这个更新时，记得一定要加上id，而且<code>values()</code>括号里面放的是数据库字段，不是java对象的属性字段：
<img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210905185036422.png" alt="image-20210905185036422"></p>
<h2 id="delayed关键字">DELAYED关键字</h2>
<p>延迟插入操作</p>
<p>DELAYED调节符应用于INSERT和REPLACE语句。当DELAYED插入操作到达的时候i，服务器把数据行放入一个队列中，并立即给客户端返回一个状态信息，这样客户端就可以在数据表被真正地插入记录之前继续进行着操作了。如果读取者从该数据表中读取数据，队列中的数据就会被保持着，直到没有读取者为止。接着服务器开始插入延迟数据行（delayed-row）队列中的数据行。在插入操作的同时，服务器还要检查是否有新的读取请求到达和等待。如果有，延迟数据行队列就被挂起，允许读取者继续操作。当没有读取者的时候，服务器再次开始插入延迟的数据行。这个过程一直进行，直到队列空了为止。</p>
<p>下面几点要注意的事项：</p>
<ul>
<li>INSERT DELAYED应该仅用于指定值清单的INSERT语句。服务器忽略用于INSERT DELAYED&hellip;SELECT语句的DELAYED</li>
<li>服务器忽略用于INSERT DELAYED&hellip;ON DUPLICATE UPDATE语句的DELAYED</li>
<li>因为在行被插入前，语句立刻返回，所以您不能使用LAST_INSETT_ID()来获取AUTO_INCREMENT值。AUTO_INCREMENT值可能由语句生成。</li>
<li>对于SELECT语句，DELAYED行不可见，直到这些行确实被插入了为止。</li>
<li>DELAYED在从属复制服务器中被忽略了，因为DELAYED不会在从属服务器中产生与主服务器不一样的数据。注意，目前在队列中的各行只保存在存储器中，直到它们被插入到表中为止。这意味着，如果你强行终止了mysql或者如果mysql意外停止，则所有没有写入磁盘的行都会丢失。</li>
</ul>
<h2 id="cache-index语句">CACHE INDEX语句</h2>
<p>语法：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">CACHE</span> <span class="k">INDEX</span> <span class="err">{</span>
<span class="n">tbl_index_list</span> <span class="p">[,</span> <span class="n">tbl_index_list</span><span class="p">]</span> <span class="p">...</span>
<span class="o">|</span> <span class="n">tbl_name</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">partition_list</span><span class="p">)</span>
<span class="err">}</span>
<span class="k">IN</span> <span class="n">key_cache_name</span>
<span class="c1">-- tbl_index_list: tbl_name [{INDEX|KEY} (index_name [, index_name] ...)] --
</span><span class="c1">-- partition_list: {partition_name[, partition_name] ... | ALL} --
</span></code></pre></div><p>CACHE INDEX语句将表索引分配给特定的键缓存。它只适用于MyISAM表，包括分区的MyISAM表。分配索引后，如果需要，可以将它们预加载到缓存中，并将索引加载到缓存中。
以下语句将表t1、t2和t3中的索引分配给名为hot_cache的密钥缓存：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">CACHE</span> <span class="k">INDEX</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="k">IN</span> <span class="n">hot_cache</span><span class="p">;</span>
</code></pre></div><p>CACHE INDEX的语法使您可以指定仅将表中的特定索引分配给高速缓存。但是，该实现将表的所有索引分配给高速缓存，因此，除了表名外，没有其他必要指定任何内容。</p>
<p>CACHE INDEX可以通过使用参数设置语句或在服务器参数设置中设置其大小来创建语句中 引用的键高速缓存。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="kt">SET</span> <span class="n">GLOBAL</span> <span class="n">keycache1</span><span class="p">.</span><span class="n">key_buffer_size</span><span class="o">=</span><span class="mi">128</span><span class="o">*</span><span class="mi">1024</span><span class="p">;</span>
</code></pre></div><p>关键高速缓存参数作为结构化系统变量的成员进行访问。
在为其分配索引之前，键高速缓存必须存在，否则会发生错误：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">CACHE</span> <span class="k">INDEX</span> <span class="n">t1</span> <span class="k">IN</span> <span class="n">non_existent_cache</span><span class="p">;</span>
<span class="c1">-- ERROR 1284 (HY000): Unknown key cache &#39;non_existent_cache&#39; -- 
</span></code></pre></div><p>默认情况下，表索引分配给服务器启动时创建的主（默认）键高速缓存。销毁键高速缓存时，分配给它的所有索引都将重新分配给默认键高速缓存。
索引分配会全局影响服务器：如果一个客户端将索引分配给给定的缓存，则该缓存将用于涉及该索引的所有查询，无论哪个客户端发出查询。
CACHE INDEX支持分区MyISAM表。您可以将一个，多个或所有分区的一个或多个索引分配给给定的键高速缓存。例如，您可以执行以下操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">pt</span> <span class="p">(</span><span class="n">c1</span> <span class="kt">INT</span><span class="p">,</span> <span class="n">c2</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span> <span class="k">INDEX</span> <span class="nf">i</span><span class="p">(</span><span class="n">c1</span><span class="p">))</span>
<span class="kp">ENGINE</span><span class="o">=</span><span class="n">MyISAM</span>
<span class="n">PARTITION</span> <span class="k">BY</span> <span class="nf">HASH</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="n">PARTITIONS</span> <span class="mi">4</span><span class="p">;</span>

<span class="kt">SET</span> <span class="n">GLOBAL</span> <span class="n">kc_fast</span><span class="p">.</span><span class="n">key_buffer_size</span> <span class="o">=</span> <span class="mi">128</span> <span class="mi">1024</span><span class="p">;</span>
<span class="kt">SET</span> <span class="n">GLOBAL</span> <span class="n">kc_slow</span><span class="p">.</span><span class="n">key_buffer_size</span> <span class="o">=</span> <span class="mi">128</span> <span class="mi">1024</span><span class="p">;</span>

<span class="n">CACHE</span> <span class="k">INDEX</span> <span class="n">pt</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">p0</span><span class="p">)</span> <span class="k">IN</span> <span class="n">kc_fast</span><span class="p">;</span>
<span class="n">CACHE</span> <span class="k">INDEX</span> <span class="n">pt</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p3</span><span class="p">)</span> <span class="k">IN</span> <span class="n">kc_slow</span><span class="p">;</span>
</code></pre></div><p>上一组语句执行以下操作：</p>
<p>创建一个包含4个分区的分区表；这些分区会自动命名为p0，&hellip;，p3; 该表的索引名为 icolumn c1。</p>
<p>创建两个名为kc_fast和的 密钥缓存kc_slow</p>
<p>受让人为分区的索引p0的 kc_fast键缓存和用于分区的索引p1和p3 到kc_slow键缓存; 其余分区的索引（p2）使用服务器的默认键缓存。</p>
<p>如果希望将表中所有分区的索引分配给pt名为的单个键高速缓存 kc_all，则可以使用以下两个语句之一：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">CACHE</span> <span class="k">INDEX</span> <span class="n">pt</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="k">ALL</span><span class="p">)</span> <span class="k">IN</span> <span class="n">kc_all</span><span class="p">;</span>
<span class="n">CACHE</span> <span class="k">INDEX</span> <span class="n">pt</span> <span class="k">IN</span> <span class="n">kc_all</span><span class="p">;</span>
</code></pre></div><p>上面两个语句是等效的，发出其中一个具有完全相同的效果。换句话说，如果您希望将分区表的所有分区的索引分配给同一键高速缓存，则该PARTITION (ALL)子句是可选的。</p>
<p>在将多个分区的索引分配给键高速缓存时，这些分区不必是连续的，并且您无需以任何特定顺序列出其名称。未明确分配给键高速缓存的任何分区的索引将自动使用服务器默认键高速缓存。</p>
<p>分区MyISAM表还支持索引预加载 。</p>
<h2 id="load-index-into-cache语句">LOAD INDEX INTO CACHE语句</h2>
<p>语法：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">LOAD</span> <span class="k">INDEX</span> <span class="k">INTO</span> <span class="n">CACHE</span><span class="err">{</span>
<span class="n">tbl_index_list</span> <span class="p">[,</span> <span class="n">tbl_index_list</span><span class="p">]</span> <span class="p">...</span>
<span class="o">|</span> <span class="n">tbl_name</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">partition_list</span><span class="p">)</span>
<span class="err">}</span>

<span class="c1">-- tbl_index_list:
</span><span class="c1">--  tbl_name
</span><span class="c1">--    [PARTITION (partition_list)]
</span><span class="c1">--    [{INDEX|KEY} (index_name[, index_name] ...)]
</span><span class="c1">--    [IGNORE LEAVES]
</span><span class="c1"></span>
<span class="c1">-- partition_list: {
</span><span class="c1">--    partition_name[, partition_name] ...
</span><span class="c1">--  | ALL
</span><span class="c1">-- }
</span></code></pre></div><p>LOAD INDEX INTO CACHE语句将表索引预加载到由显式CACHE INDEX语句为其分配的键高速缓存中，否则预加载 到默认键高速缓存中。
LOAD INDEX INTO CACHE仅适用于MyISAM 表，包括分区MyISAM表。此外，分区表上的索引可以预载一个，几个或所有分区。</p>
<p>所述IGNORE LEAVES改性剂导致要预装只为索引的非叶结点的块。</p>
<p>IGNORE LEAVES分区MyISAM表也受支持。</p>
<p>以下语句为表t1和的索引预加载节点（索引块）t2：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">LOAD</span> <span class="k">INDEX</span> <span class="k">INTO</span> <span class="n">CACHE</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="k">IGNORE</span> <span class="n">LEAVES</span><span class="p">;</span>
</code></pre></div><p>该语句从中预加载所有索引块 t1。它仅从中预加载非叶节点的块t2。</p>
<p>的语法LOAD INDEX INTO CACHE使您可以指定仅应预加载表中的特定索引。但是，该实现将表的所有索引都预加载到缓存中，因此，除了表名外，没有其他必要指定其他内容。</p>
<p>可以在分区MyISAM表的特定分区上预加载索引。例如，在以下2条语句中，第一条预加载已分区表pt的分区p0的索引，而第二条预加载同一表的分区p1和p3的索引：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">LOAD</span> <span class="k">INDEX</span> <span class="k">INTO</span> <span class="n">CACHE</span> <span class="n">pt</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">p0</span><span class="p">);</span>
<span class="k">LOAD</span> <span class="k">INDEX</span> <span class="k">INTO</span> <span class="n">CACHE</span> <span class="n">pt</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p3</span><span class="p">);</span>
</code></pre></div><p>要预加载table中所有分区的索引 pt，可以使用以下两个语句之一：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">LOAD</span> <span class="k">INDEX</span> <span class="k">INTO</span> <span class="n">CACHE</span> <span class="n">pt</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="k">ALL</span><span class="p">);</span>
<span class="k">LOAD</span> <span class="k">INDEX</span> <span class="k">INTO</span> <span class="n">CACHE</span> <span class="n">pt</span><span class="p">;</span>
</code></pre></div><p>上面两句是等效的。换句话说，如果您希望为分区表的所有分区预加载索引，则该 PARTITION (ALL)子句是可选的。</p>
<p>当预加载多个分区的索引时，这些分区不必是连续的，并且您无需以任何特定顺序列出其名称。</p>
<p>LOAD INDEX INTO CACHE &hellip; IGNORE LEAVES失败，除非表中的所有索引具有相同的块大小。要确定表的索引块大小，请使用myisamchk -dv并检查Blocksize列。</p>
<h2 id="ignore关键字">IGNORE关键字</h2>
<p>MySQL提供了ignore用来避免数据的重复插入，若有导致unique key冲突的记录，则该条记录不会被插入到数据库中</p>
<p>举例：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">INSERT</span> <span class="k">IGNORE</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">tbl_name</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">email</span><span class="o">`</span><span class="p">,</span> <span class="o">`</span><span class="n">phone</span><span class="o">`</span><span class="p">,</span> <span class="o">`</span><span class="n">user_id</span><span class="o">`</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="s1">&#39;test9@163.com&#39;</span><span class="p">,</span> <span class="s1">&#39;99999&#39;</span><span class="p">,</span> <span class="s1">&#39;9999&#39;</span><span class="p">);</span>
<span class="c1">-- 如果有重复记录就会忽略，执行后返回数字0 --
</span></code></pre></div><p>还有个应用是复制表的时候避免重复记录：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">INSERT</span> <span class="k">IGNORE</span> <span class="k">INTO</span> <span class="o">`</span><span class="n">tbl_name</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">col</span><span class="o">`</span><span class="p">)</span> <span class="k">SELECT</span> <span class="o">`</span><span class="n">col</span><span class="o">`</span> <span class="k">FROM</span> <span class="o">`</span><span class="n">tbl_name2</span><span class="o">`</span><span class="p">;</span>
</code></pre></div><h2 id="select--for-update使用方法">SELECT &hellip; FOR UPDATE使用方法</h2>
<p>作用：</p>
<p>select for update是为了在查询时，避免其他用户以该表进行插入，修改或删除等操作，造成表的不一致性</p>
<p>举例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">for</span> <span class="k">update</span><span class="p">;</span> <span class="c1">-- 会等待行锁释放之后，返回查询结果
</span><span class="c1"></span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">for</span> <span class="k">update</span> <span class="n">nowait</span><span class="p">;</span> <span class="c1">-- 不等待行锁释放，提示锁冲突，不返回结果
</span><span class="c1"></span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">for</span> <span class="k">update</span> <span class="n">wait</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">-- 等待5秒，若行锁仍未释放，则提示锁冲突，不返回结果
</span><span class="c1"></span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t</span> <span class="k">for</span> <span class="k">update</span> <span class="n">skip</span> <span class="n">locked</span><span class="p">;</span> <span class="c1">-- 查询返回查询结果，但忽略有行锁的记录
</span></code></pre></div><p>select &hellip; for update语句的语法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="p">...</span> <span class="k">FOR</span> <span class="k">UPDATE</span> <span class="p">[</span><span class="n">OF</span> <span class="n">column_list</span><span class="p">][</span><span class="n">WAIT</span> <span class="n">n</span><span class="o">|</span><span class="n">NOWAIT</span><span class="p">][</span><span class="n">SKIP</span> <span class="n">LOCKED</span><span class="p">];</span>
<span class="c1">-- 其中：
</span><span class="c1">-- OF子句用于指定即将更新的列，即锁定行上的特定列
</span><span class="c1">-- WAIT子句指定等待其他用户释放锁的秒数，防止无限期的等待
</span><span class="c1"></span>
<span class="c1">-- 使用FOR UPDATE WAIT子句的优点如下：
</span><span class="c1">-- 1、防止无限期地等待被锁定的行
</span><span class="c1">-- 2、允许应用程序中对锁的等待时间进行更多的控制
</span><span class="c1">-- 3、对于交互式应用程序非常有用，因为这些用户不能等待不确定
</span><span class="c1">-- 4、若使用了skip locked，则可以越过锁定的行，不会报告由wait n引发的‘资源忙’异常报告
</span></code></pre></div><p>补充：</p>
<p>分成两类：加锁范围子句和加锁行为子句</p>
<p>**加锁范围子句：**在select &hellip; for update之后，可以使用of子句选择对select的特定数据表进行加锁操作。默认情况下，不使用of子句表示在select所有的数据表中加锁</p>
<p>**加锁行为子句：**当我们进行for update的操作时，与普通select存在很大不同。一般select是不需要考虑数据是否被锁定，最多根据多版本一致读的特性读取之前的版本。加入for update之后，Oracle就要求启动一个新事务，尝试对数据进行加锁。如果当前已经被加锁，默认的行为必然是block等待。使用nowait子句的作用就是避免进行等待，当发现请求加锁资源被锁定未释放的时候，直接报错返回。</p>
<p>在日常中，我们对for update的使用还是比较普遍的，特别是在如pl/sql developer中手工修改数据。此时只是觉得方便，而对for update真正的含义缺乏理解。</p>
<p>For update是Oracle提供的手工提高锁级别和范围的特例语句。Oracle的锁机制是目前各类型数据库锁机制中比较优秀的。所以，Oracle认为一般不需要用户和应用直接进行锁的控制和提升。甚至认为死锁这类锁相关问题的出现场景，大都与手工提升锁有关。</p>
<p>所以，Oracle并不推荐使用for update作为日常开发使用。而且，在平时开发和运维中，使用了for update却忘记提交，会引起很多锁表故障。 <!-- raw HTML omitted -->那么，什么时候需要使用for update？就是那些需要业务层面数据独占时，可以考虑使用for update。场景上，比如火车票订票，在屏幕上显示邮票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。<!-- raw HTML omitted -->所以，在这个确认过程中，可以使用for update。这是统一的解决方案方案问题，需要前期有所准备。</p>
<h2 id="筛选并查看变量">筛选并查看变量</h2>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">show</span> <span class="n">variables</span> <span class="k">where</span> <span class="n">variable_name</span> <span class="k">like</span> <span class="s1">&#39;wait%&#39;</span> <span class="k">and</span> <span class="n">value</span><span class="o">=</span><span class="s1">&#39;on&#39;</span><span class="p">;</span>
</code></pre></div><h2 id="查看已安装的插件">查看已安装的插件</h2>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SHOW</span> <span class="n">PLUGINS</span><span class="p">;</span>
</code></pre></div><h2 id="generated-column">generated column</h2>
<p>定义Generated column列的语法如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="err">列名</span> <span class="err">类型</span> <span class="p">[</span><span class="n">GENERATED</span> <span class="n">ALWAYS</span><span class="p">]</span> <span class="k">AS</span> <span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="p">[</span><span class="n">VIRTUAL</span> <span class="o">|</span> <span class="n">STORED</span><span class="p">]</span> <span class="p">[</span><span class="k">NOT</span> <span class="no">NULL</span> <span class="o">|</span> <span class="no">NULL</span><span class="p">]</span> <span class="p">[</span><span class="k">UNIQUE</span> <span class="p">[</span><span class="k">KEY</span><span class="p">]]</span> <span class="p">[[</span><span class="k">PRIMARY</span><span class="p">]</span> <span class="k">KEY</span><span class="p">]</span> <span class="p">[</span><span class="n">COMMENT</span> <span class="s1">&#39;string&#39;</span><span class="p">]</span>
</code></pre></div><ul>
<li>AS（expr）用于生成计算列值的表达式。</li>
<li>VIRTUAL或STORED关键字表示是否存储计算列的值
<ul>
<li>VIRTUAL：默认就是设置为VIRTUAL。不存储该列值，即MySQL只是将这一列的元信息保存在数据字典中，并不会将这一列数据持久化到磁盘上，而是当读取该行时，触发触发器对该列进行计算显示。InnoDB支持Virtual Generated Column。</li>
<li>STORED：在添加或更新行时计算并存储列值。存储列需要存储空间，并且可以创建索引。所以相对于Virtual Column列需要更多的磁盘空间，与Virtual Column相比并没有优势。因此，MySQL 5.7中，不指定Generated Column的类型，默认是Virtual Column。</li>
<li>在表中允许Virtual Column和Stored Column的混合使用</li>
<li><strong>提高效率：由于mysql在普通索引上加函数会造成索引失效，造成查询性能下降，Generated Column（函数索引）刚好可以解决这个问题，可以在Generated Column加上索引来提高效率</strong></li>
</ul>
</li>
</ul>
<p>注意：还可以在generated column上建立索引以加快查找速度</p>
<p>计算列表达式的要求：</p>
<ul>
<li>
<p>允许使用文本、内置函数和运算符，但不能使用返回值不确定的函数，比如NOW()。</p>
</li>
<li>
<p>不允许使用存储函数和用户定义函数。</p>
</li>
<li>
<p>不允许使用存储过程和函数参数。</p>
</li>
<li>
<p>不允许使用变量（系统变量、用户定义变量和存储程序的局部变量）。</p>
</li>
<li>
<p>不允许子查询。</p>
</li>
<li>
<p>计算列在定义时可以引用其他的计算列，但只能引用表定义中较早出现的列。</p>
</li>
<li>
<p>可以在计算列上创建索引，但不能在VIRTUAL类型的计算列上创建聚集索引。</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">create</span> <span class="k">table</span> <span class="nf">t1</span><span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span> <span class="p">,</span> <span class="n">c</span> <span class="kt">int</span> <span class="n">GENERATED</span> <span class="n">ALWAYS</span> <span class="k">AS</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">),</span> <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="n">ERROR</span> <span class="mi">3106</span> <span class="p">(</span><span class="n">HY000</span><span class="p">):</span> <span class="s1">&#39;Defining a virtual generated column as primary key&#39;</span> <span class="k">is</span> <span class="k">not</span> <span class="n">supported</span> <span class="k">for</span> <span class="n">generated</span> <span class="n">columns</span><span class="p">.</span>
  
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">create</span> <span class="k">table</span> <span class="nf">t1</span><span class="p">(</span><span class="n">a</span> <span class="kt">int</span><span class="p">,</span> <span class="n">b</span> <span class="kt">int</span> <span class="p">,</span> <span class="n">c</span> <span class="kt">int</span> <span class="n">GENERATED</span> <span class="n">ALWAYS</span> <span class="k">AS</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="n">STORED</span><span class="p">,</span> <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="n">rows</span> <span class="nf">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">11</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></li>
<li>
<p>不能在Virtual Generated Column上创建全文索引和空间索引</p>
</li>
<li>
<p>Virtual Generated Column不能作为外键</p>
</li>
</ul>
<h3 id="generated-column上创建索引与oracle的函数索引的区别">Generated Column上创建索引与Oracle的函数索引的区别</h3>
<p>首先创建表：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">t1</span> <span class="p">(</span><span class="n">first_name</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">last_name</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
</code></pre></div><p>假设这时候需要建一个full_name的索引，在Oracle中，我们可以直接在创建索引的时候使用函数，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">alter</span> <span class="k">table</span> <span class="n">t1</span> <span class="k">add</span> <span class="k">index</span> <span class="nf">full_name_idx</span><span class="p">(</span><span class="nf">CONCAT</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">last_name</span><span class="p">));</span> 
</code></pre></div><p>但是，上面这条语句在MySQL中就会报错。在MySQL中，我们可以先新建一个Generated Column，然后再在这个Generated Column上建索引，如下所示：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">alter</span> <span class="k">table</span> <span class="n">t1</span> <span class="k">add</span> <span class="k">column</span> <span class="n">full_name</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="n">GENERATED</span> <span class="n">ALWAYS</span> <span class="k">AS</span> <span class="p">(</span><span class="nf">CONCAT</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">last_name</span><span class="p">));</span>
<span class="k">alter</span> <span class="k">table</span> <span class="n">t1</span> <span class="k">add</span> <span class="k">index</span> <span class="nf">full_name_idx</span><span class="p">(</span><span class="n">full_name</span><span class="p">);</span>
</code></pre></div><p>乍一看，MySQL需要在表上增加一列，才能够实现类似Oracle的函数索引，似乎代价会高很多。但是，我们在上面提过，对于Virtual Generated Column，MySQL只是将这一列的元信息保存在数据字典中，并不会将这一列数据持久化到磁盘上，因此，在MySQL的Virtual Generated Column上建立索引和Oracle的函数索引类似，并不需要更多的代价，只是使用方式有点不一样而已。</p>
<h2 id="binary类型">Binary类型</h2>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">test_bin</span> <span class="p">(</span>
   <span class="n">bin_id</span> <span class="k">BINARY</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span>
<span class="p">)</span> <span class="kp">Engine</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span> 
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="nf">test_bin</span><span class="p">(</span><span class="n">bin_id</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="nf">UNHEX</span><span class="p">(</span><span class="err">‘</span><span class="n">FA34E10293CB42848573A4E39937F479</span><span class="err">‘</span><span class="p">));</span>
<span class="c1">-- 或 --
</span><span class="c1"></span><span class="k">INSERT</span> <span class="k">INTO</span> <span class="nf">test_bin</span><span class="p">(</span><span class="n">bin_id</span><span class="p">)</span> <span class="k">VALUES</span><span class="p">(</span><span class="n">x</span><span class="err">‘</span><span class="n">FA34E10293CB42848573A4E39937F479</span><span class="err">‘</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="nf">HEX</span><span class="p">(</span><span class="n">bin_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">bin_id</span> <span class="k">FROM</span> <span class="n">test_bin</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="nf">HEX</span><span class="p">(</span><span class="n">bin_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">bin_id</span> <span class="k">FROM</span> <span class="n">test_bin</span> <span class="k">WHERE</span> <span class="n">bin_id</span> <span class="o">=</span> <span class="nf">UNHEX</span><span class="p">(</span><span class="err">‘</span><span class="n">FA34E10293CB42848573A4E39937F479</span><span class="err">‘</span><span class="p">);</span>
<span class="k">SELECT</span> <span class="nf">HEX</span><span class="p">(</span><span class="n">bin_id</span><span class="p">)</span> <span class="k">AS</span> <span class="n">bin_id</span> <span class="k">FROM</span> <span class="n">test_bin</span> <span class="k">WHERE</span> <span class="n">bin_id</span> <span class="o">=</span> <span class="n">x</span><span class="err">‘</span><span class="n">FA34E10293CB42848573A4E39937F479</span><span class="err">‘</span><span class="p">;</span>
</code></pre></div><p>Binary妙用：</p>
<p>假设表t_user有字段name类型是varchar，那么要求根据name来做筛选</p>
<p>where自居的字符串比较是不区分大小写的，但是可以使用binary关键字设定where子句区分大小写：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t_user</span> <span class="k">where</span> <span class="k">binary</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Zhangsan&#39;</span><span class="p">;</span> <span class="c1">-- 搜不到东西 --
</span><span class="c1"></span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">t_user</span> <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;Zhangsan&#39;</span><span class="p">;</span> <span class="c1">-- 可以搜到name为zhangsan的 -- 
</span></code></pre></div><h2 id="unsigned类型">unsigned类型</h2>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">-- 其实就跟c语言中的unsigned差不多 --
</span><span class="c1"></span><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">t</span><span class="p">(</span>
    <span class="n">a</span> <span class="kt">INT</span> <span class="k">UNSIGNED</span><span class="p">,</span>
    <span class="n">b</span> <span class="kt">INT</span> <span class="k">UNSIGNED</span>
<span class="p">)</span><span class="kp">ENGINE</span><span class="o">=</span><span class="n">INNODB</span><span class="p">;</span>
</code></pre></div><h2 id="zerofill">ZEROFILL</h2>
<p>zerofill 默认是unsigned</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">t</span><span class="p">(</span>
    <span class="n">a</span> <span class="kt">INT</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">ZEROFILL</span><span class="p">,</span>
<span class="p">)</span><span class="kp">ENGINE</span><span class="o">=</span><span class="n">INNODB</span><span class="p">;</span>
<span class="c1">-- 向表t插入a为10的一条数据
</span><span class="c1">-- 执行select语句查询a结果为0010
</span></code></pre></div><h2 id="comment">COMMENT</h2>
<p>用于对字段进行说明</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">mytest</span><span class="o">`</span><span class="p">(</span>
	<span class="o">`</span><span class="kt">text</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="n">COMMENT</span> <span class="s1">&#39;内容&#39;</span>
<span class="p">)</span><span class="kp">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
</code></pre></div><h2 id="replace-into">REPLACE INTO</h2>
<p>有这样一种场景：如果没有则插入，如果有则更新。</p>
<p>我们当然可以用insert、update、select来做到这点，但是效率太低，此时就可以使用replace [into]，into可以省略。</p>
<ul>
<li>
<p>语法1：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">REPLACE</span> <span class="p">[</span><span class="k">INTO</span><span class="p">]</span> <span class="nf">tbl_name</span><span class="p">(</span><span class="n">col_name1</span><span class="p">,</span> <span class="n">col_name2</span><span class="p">,</span> <span class="p">...)</span> <span class="k">VALUES</span> <span class="p">(...);</span>
</code></pre></div></li>
<li>
<p>语法2：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">REPLACE</span> <span class="p">[</span><span class="k">INTO</span><span class="p">]</span> <span class="nf">tbl_name</span><span class="p">(</span><span class="n">col_name1</span><span class="p">,</span> <span class="n">col_name2</span><span class="p">,</span> <span class="p">...)</span> <span class="k">SELECT</span> <span class="p">...;</span>
</code></pre></div><p>replace select 的用法类似于insert select，这种方法并不一定要求列名匹配，事实上，MYSQL甚至不关心SELECT返回的列名，它需要的是列的位置</p>
<p>例子1：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">REPLACE</span> <span class="p">[</span><span class="k">INTO</span><span class="p">]</span> <span class="nf">tbl1</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">mood</span><span class="p">)</span> <span class="k">SELECT</span> <span class="n">rname</span><span class="p">,</span> <span class="n">rtitle</span><span class="p">,</span> <span class="n">rmood</span> <span class="k">from</span> <span class="n">tbl2</span><span class="p">;</span>
<span class="c1">-- 意思是将tbl2中的所有数据导入到tbl1中 -- 
</span></code></pre></div><p>例子2：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">REPLACE</span> <span class="p">[</span><span class="k">INTO</span><span class="p">]</span> <span class="nf">tbl1</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">update_time</span><span class="p">)</span> <span class="k">SELECT</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">now</span><span class="p">();</span>
</code></pre></div></li>
<li>
<p>语法3：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">REPLACE</span> <span class="p">[</span><span class="k">INTO</span><span class="p">]</span> <span class="n">tbl1</span> <span class="kt">SET</span> <span class="n">col_name</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="p">...;</span>
</code></pre></div><p>replace set 的用法类似于update set ，如果使用一个例如“SET col_name = col_name + 1”的赋值，则对于右侧的列名称的引用会被作为DEFAULT(col_name)处理。因此，该赋值相当于“SET col_name = DEFAULT(col_name) + 1”</p>
</li>
</ul>
<p>replace into 跟insert功能类似，不同点在于：replace into 首先尝试插入数据到表中，如果发现表中已经有此行数据**（根据主键或者唯一索引判断）**则先删除此行数据，然后插入新的数据，否则，直接插入新的数据。</p>
<p><strong>要注意的是，插入数据的表必须要有主键或者唯一索引，否则，replace into 会直接插入数据，这将导致表中出现重复的数据。</strong></p>
<p>在实际使用中语法1和语法2会用的多一些。虽然replace into中的into可以省略，但是最好还是加上，因为这样意思更加直观</p>
<p>另外，对于那些没有给予值的列，MySQL将自动为这些列赋上默认值。</p>
<h2 id="内连接外连接">内连接、外连接</h2>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="p">(</span><span class="n">a1</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="n">a2</span><span class="p">.</span><span class="n">name</span> <span class="k">from</span> <span class="n">b</span> <span class="k">left</span> <span class="k">join</span> <span class="n">a</span> <span class="k">as</span> <span class="n">a1</span> <span class="k">on</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">a1</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="k">left</span> <span class="k">join</span> <span class="n">a</span> <span class="k">as</span> <span class="n">a2</span> <span class="k">on</span> <span class="n">b</span><span class="p">.</span><span class="n">hid</span> <span class="o">=</span> <span class="n">a2</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="err">表</span><span class="mi">1</span> <span class="k">as</span> <span class="n">x1</span> <span class="k">inner</span> <span class="k">join</span> <span class="err">表</span><span class="mi">2</span> <span class="k">as</span> <span class="n">x2</span> <span class="k">on</span> <span class="n">x1</span><span class="p">.</span><span class="s1">&#39;id&#39;</span><span class="o">=</span><span class="n">x2</span><span class="p">.</span><span class="s1">&#39;hyuid&#39;</span> <span class="k">and</span>
<span class="s1">&#39;hyuid&#39;</span><span class="o">=</span><span class="mi">1600702113</span><span class="p">;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="p">(</span><span class="k">select</span> <span class="n">goods_id</span><span class="p">,</span><span class="n">cat_id</span><span class="p">,</span><span class="n">goods_name</span> <span class="k">from</span> <span class="n">goods</span> <span class="k">order</span> <span class="k">by</span> <span class="n">cat_id</span>
<span class="k">asc</span><span class="p">,</span><span class="n">goods_id</span> <span class="k">desc</span><span class="p">)</span> <span class="k">as</span> <span class="n">temp</span> <span class="k">group</span> <span class="k">by</span> <span class="n">cat_id</span><span class="p">;</span>
</code></pre></div><h2 id="外键约束on-delete和on-update的使用">外键约束（on delete和on update）的使用</h2>
<p><strong>外键约束（On Delete和On Update）都有Restrict，No Action, Cascade,Set Null属性。</strong></p>
<p><strong>外键约束1&ndash;ON DELETE</strong>
A.restrict(约束):当在父表（即外键的来源表）中删除对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除。
B.no action:意思同restrict.即如果存在从数据，不允许删除主数据。
C.cascade(级联):当在父表（即外键的来源表）中删除对应记录时，首先检查该记录是否有对应外键，如果有则也删除外键在子表（即包含外键的表）中的记录。
D.set null:当在父表（即外键的来源表）中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（不过这就要求该外键允许取null）</p>
<p><strong>外键约束2&ndash;ON UPDATE</strong>
A.restrict(约束):当在父表（即外键的来源表）中更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许更新。
B.no action:意思同restrict.
C.cascade(级联):当在父表（即外键的来源表）中更新对应记录时，首先检查该记录是否有对应外键，如果有则也更新外键在子表（即包含外键的表）中的记录。
D.set null:当在父表（即外键的来源表）中更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（不过这就要求该外键允许取null）。</p>
<p>注：NO ACTION和RESTRICT的区别：只有在及个别的情况下会导致区别，前者是在其他约束的动作之后执行，后者具有最高的优先权执行。</p>
<p>案例：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span>  <span class="o">`</span><span class="n">filedb</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">tblfile</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">FileID</span><span class="o">`</span> <span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">unsigned</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span><span class="p">,</span>
  <span class="o">`</span><span class="n">FileOwner</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="no">NULL</span> <span class="n">COMMENT</span> <span class="s1">&#39;外键，引用用户表&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">FileName</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="n">COMMENT</span> <span class="s1">&#39;文件原始名称&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">FilePath</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="n">COMMENT</span> <span class="s1">&#39;文件存放路径&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">FileType</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="n">COMMENT</span> <span class="s1">&#39;文件类型&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">FileSubject</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="n">COMMENT</span> <span class="s1">&#39;文件标题&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">FileCreated</span><span class="o">`</span> <span class="kt">datetime</span> <span class="k">DEFAULT</span> <span class="s1">&#39;0000-00-00 00:00:00&#39;</span> <span class="n">COMMENT</span> <span class="s1">&#39;创建时间&#39;</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">FileID</span><span class="o">`</span><span class="p">),</span>
  <span class="k">KEY</span> <span class="o">`</span><span class="n">FK_tblfile_1</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">FileOwner</span><span class="o">`</span><span class="p">),</span>
  <span class="k">CONSTRAINT</span> <span class="o">`</span><span class="n">FK_tblfile_1</span><span class="o">`</span> <span class="k">FOREIGN</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">FileOwner</span><span class="o">`</span><span class="p">)</span> <span class="k">REFERENCES</span> <span class="o">`</span><span class="n">tbluser</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">UserID</span><span class="o">`</span><span class="p">)</span> <span class="k">ON</span> <span class="k">DELETE</span> <span class="kt">SET</span> <span class="no">NULL</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">CASCADE</span> 
<span class="p">)</span> <span class="kp">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="kp">AUTO_INCREMENT</span><span class="o">=</span><span class="mi">2</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
<span class="c1">-- 那么如果我删除用户表中ST001对应记录时，则根据ON DELETE SET NULL规则，文件表中FileOwner应该被设置为null，动手尝试后也确实如此；如果我将用户表中ST001改为ST003，则根据ON UPDATE CASCADE规则，文件表中FileOwner应该连锁设置为ST003，也的确如此。
</span></code></pre></div><p><strong>on delete和on update也可以作用于timestamp时间戳类型的字段</strong></p>
<p>案例：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">mytest</span><span class="o">`</span><span class="p">(</span>
	<span class="o">`</span><span class="kt">text</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="n">COMMENT</span> <span class="s1">&#39;内容&#39;</span><span class="p">,</span>
    <span class="o">`</span><span class="n">created_at</span><span class="o">`</span> <span class="kt">timestamp</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="n">COMMENT</span> <span class="s1">&#39;创建时间&#39;</span><span class="p">,</span>
    <span class="o">`</span><span class="n">updated_at</span><span class="o">`</span> <span class="kt">timestamp</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="n">COMMENT</span> <span class="s1">&#39;更新时间&#39;</span>
<span class="p">)</span><span class="kp">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
</code></pre></div><p>外键的使用对于减少数据库冗余性，以及保证数据完整性和一致性有很大作用。</p>
<p>另外注意，如果两张表之间存在外键关系，则MySQL不能直接删除表(Drop Table)，而应该先删除外键，之后才可以删除。</p>
<h2 id="外键约束以及建立索引-create-index">外键约束以及建立索引（ create index）</h2>
<p>// 添加外键约束以及建立索引（底层B+树，提高效率）如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">table</span> <span class="nf">Three_student</span><span class="p">(</span>
    <span class="n">id</span> <span class="kt">int</span> <span class="kp">auto_increment</span>
    <span class="k">primary</span> <span class="k">key</span><span class="p">,</span>
    <span class="n">s_name</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">not</span> <span class="no">null</span><span class="p">,</span>
    <span class="n">s_grade_id</span> <span class="kt">int</span> <span class="k">not</span> <span class="no">null</span><span class="p">,</span>
    <span class="k">constraint</span> <span class="n">Three_student_s_grade_id_ffbb8485_fk_Three_grade_id</span>
    <span class="k">foreign</span> <span class="k">key</span> <span class="p">(</span><span class="n">s_grade_id</span><span class="p">)</span> <span class="k">references</span> <span class="nf">Three_grade</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span>
<span class="p">);</span>
<span class="k">create</span> <span class="k">INDEX</span> <span class="n">Three_student_s_grade_id_ffbb8485_fk_Three_grade_id</span> <span class="k">on</span> <span class="nf">Three_student</span><span class="p">(</span><span class="n">s_grade_id</span><span class="p">);</span>
</code></pre></div><h2 id="mysql的current_timestamp">Mysql的CURRENT_TIMESTAMP</h2>
<p>在创建时间字段的时候（比方说常见的created_at和updated_at）</p>
<p>创建一条数据记录的时候，我们可能会希望created_at和updated_at这两个字段能够自动创建</p>
<p><strong>DEFAULT CURRENT_TIMESTAMP</strong></p>
<p>表示当插入数据的时候，该字段默认值为当前时间</p>
<p><strong>ON UPDATE CURRENT_TIMESTAMP</strong></p>
<p>表示每次更新这条数据的时候，该字段都会更新成当前时间</p>
<p>这两个操作是MySQL数据库本身在维护的，所以可以根据这个特性来生成【创建时间】和【更新时间】两个字段，且不需要代码来维护</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">mytest</span><span class="o">`</span><span class="p">(</span>
	<span class="o">`</span><span class="kt">text</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span> <span class="n">COMMENT</span> <span class="s1">&#39;内容&#39;</span><span class="p">,</span>
    <span class="o">`</span><span class="n">created_at</span><span class="o">`</span> <span class="kt">timestamp</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="n">COMMENT</span> <span class="s1">&#39;创建时间&#39;</span><span class="p">,</span>
    <span class="o">`</span><span class="n">updated_at</span><span class="o">`</span> <span class="kt">timestamp</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">ON</span> <span class="k">UPDATE</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="n">COMMENT</span> <span class="s1">&#39;更新时间&#39;</span>
<span class="p">)</span><span class="kp">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
</code></pre></div><h2 id="联合algorithm创建视图">联合algorithm创建视图</h2>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="n">algorithm</span> <span class="o">=</span> <span class="n">merge</span> <span class="n">view</span> <span class="n">v</span>
<span class="k">as</span>
<span class="k">select</span> <span class="err">语句</span><span class="p">;</span>
</code></pre></div><p>必要时使用algorithm可以用于提高效率；以上写法并不会建立临时表。</p>
<p>如果algorithm = temptable 则指定生成临时表</p>
<p>如果拿不准用什么，algorithm= undefined，让系统帮我们定</p>
<h2 id="ifnullnullif其他">Ifnull|nullif|其他</h2>
<ul>
<li>
<p>表看成集合的话一行是一个元素</p>
</li>
<li>
<p>数据库实现量表的笛卡儿积：select * from 表1,表2;</p>
</li>
<li>
<p>可以直接写 select 2&gt;1;或者select 2&lt;1或者select &lsquo;list&rsquo;=null;</p>
</li>
<li>
<p>null的比较需要用特殊的运算符,遇到其他运算符一律返回null is null , is not
null; 例如：select * from name where snum is not null;</p>
</li>
<li>
<p>在开发中，会员的信息优化往往是把频繁用到的信息，优先考虑效率，存储到一张表中，不常用的信息和比较占据空间的信息，优先考虑空间占用，存储到辅表中。</p>
</li>
<li>
<p>myisam\innodb\bdb utf8\gbk\latin1&hellip;</p>
</li>
<li>
<p>对于结果中的列如果想再筛选，用having</p>
</li>
<li>
<p>用myisam引擎时count(<em>)和count(1)没有区别。而用lnnodb引擎时，count(</em>)效率很低，因为他真的要去数一遍。</p>
</li>
<li>
<p>ifnull(&lsquo;aaa&rsquo;,0)&ndash;&gt;aaa; ifnull(null,0)&ndash;&gt;0; ifnull('',0)&ndash;&gt;'';</p>
</li>
<li>
<p>nullif(a,b) 判断a和b是否相等，相等返回1，不等返回null；</p>
</li>
<li>
<p>数据库设计（项目经理、架构师）：触发器、事物、锁、索引优化、引擎优化、表的涉及、读写分离</p>
</li>
<li>
<p>数据库的管理者（DBA 知识）：权限管理、数据备份、运行监控、性能监测</p>
</li>
</ul>
<h2 id="查看mysql网络连接相关的变量属性与网络连接状态">查看MySQL网络连接相关的变量属性与网络连接状态</h2>
<p>查看mysql网络连接的变量属性：<code>show variables like '%connection%';</code>、<code>show global variables like '%connection%';</code></p>
<p>查看mysql网络连接的状态：<code>show status like '%connection%';</code>、<code>show global status like '%connection%';</code></p>
<h2 id="索引">索引</h2>
<p>创建索引时，需要保证索引是应用在sql查询语句的条件(一般作为where子句的条件)。</p>
<p>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。索引大大提高查询速度，但降低了更新表的速度。</p>
<p>在where条件中，对某列使用了函数，则此列的索引不发挥作用。</p>
<p>mysql在使用like查询的时候只有使用后面的%时，才会使用到索引。</p>
<h3 id="创建索引">创建索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">index</span> <span class="err">索引名</span> <span class="k">on</span> <span class="err">表名</span><span class="p">(</span><span class="err">属性名</span><span class="p">(</span><span class="n">length</span><span class="p">));</span>
<span class="c1">-- 如果是char,varchar类型，length可以小于字段实际长度；如果是blob，text，必须指定length
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">alter</span> <span class="k">table</span> <span class="err">表名</span> <span class="k">add</span> <span class="k">index</span> <span class="err">索引名</span><span class="p">(</span><span class="err">列名</span><span class="p">);</span>
</code></pre></div><h3 id="创建表时添加索引">创建表时添加索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">table</span> <span class="err">表名（</span>
    <span class="n">id</span> <span class="kt">int</span> <span class="k">not</span> <span class="no">null</span><span class="p">,</span>
    <span class="n">uname</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">not</span> <span class="no">null</span><span class="p">,</span>
    <span class="k">index</span><span class="p">[</span><span class="err">索引名</span><span class="p">](</span><span class="nf">uname</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
<span class="p">);</span>
</code></pre></div><h3 id="删除索引">删除索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">drop</span> <span class="k">index</span><span class="p">[</span><span class="err">索引名</span><span class="p">]</span> <span class="k">on</span> <span class="err">表名</span><span class="p">;</span>
</code></pre></div><h3 id="普通索引">普通索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1"># 待补充 2021 05 26
</span></code></pre></div><h3 id="唯一索引">唯一索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">unique</span> <span class="k">index</span> <span class="err">索引名</span> <span class="k">on</span> <span class="err">表名（列名</span><span class="p">(</span><span class="n">length</span><span class="p">);</span> <span class="c1">-- 创建
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">alter</span> <span class="k">table</span> <span class="err">表名</span> <span class="k">add</span> <span class="k">unique</span> <span class="k">index</span><span class="p">[</span><span class="err">索引名</span><span class="p">]</span> <span class="p">(</span><span class="err">列名</span><span class="p">(</span><span class="n">length</span><span class="p">));</span> <span class="c1">-- 修改
</span></code></pre></div><h3 id="创建表时添加唯一索引">创建表时添加唯一索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">table</span> <span class="err">表名（</span>
    <span class="n">id</span> <span class="kt">int</span> <span class="k">not</span> <span class="no">null</span><span class="p">,</span>
    <span class="n">uname</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">not</span> <span class="no">null</span><span class="p">,</span>
    <span class="k">unique</span> <span class="k">index</span><span class="p">[</span><span class="err">索引名</span><span class="p">](</span><span class="nf">uname</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
<span class="p">);</span>
</code></pre></div><h3 id="有四种方式来添加数据表的索引">有四种方式来添加数据表的索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">-- 1
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">tbl_name</span> <span class="k">ADD</span> <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">column_list</span><span class="p">);</span> <span class="c1">-- 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
</span><span class="c1"></span>
<span class="c1">-- 2
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">tbl_name</span> <span class="k">ADD</span> <span class="k">UNIQUE</span> <span class="nf">index_name</span> <span class="p">(</span><span class="n">column_list</span><span class="p">);</span> <span class="c1">-- 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
</span><span class="c1"></span>
<span class="c1">-- 3
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">tbl_name</span> <span class="k">ADD</span> <span class="k">INDEX</span> <span class="nf">index_name</span> <span class="p">(</span><span class="n">column_list</span><span class="p">);</span> <span class="c1">-- 添加普通索引，索引值可出现多次。
</span><span class="c1"></span>
<span class="c1">-- 4
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">tbl_name</span> <span class="k">ADD</span> <span class="k">FULLTEXT</span> <span class="nf">index_name</span> <span class="p">(</span><span class="n">column_list</span><span class="p">);</span> <span class="c1">-- 该语句指定了索引为 FULLTEXT ，用于全文索引。
</span></code></pre></div><p>举个例子，比如你在为某商场做一个会员卡的系统。</p>
<p>这个系统有一个会员表</p>
<p>有下列字段：</p>
<p>会员编号 INT</p>
<p>会员姓名 VARCHAR(10)</p>
<p>会员身份证号码 VARCHAR(18)</p>
<p>会员电话 VARCHAR(10)</p>
<p>会员住址 VARCHAR(50)</p>
<p>会员备注信息 TEXT</p>
<p>那么这个 会员编号，作为主键，使用 PRIMARY</p>
<p>会员姓名 如果要建索引的话，那么就是普通的 INDEX</p>
<p>会员身份证号码 如果要建索引的话，那么可以选择 UNIQUE （唯一的，不允许重复）</p>
<p>会员备注信息 ，如果需要建索引的话，可以选择 FULLTEXT，全文搜索。</p>
<h3 id="回表索引下推">回表、索引下推</h3>
<p>参考：https://zhuanlan.zhihu.com/p/401198674（在Mysql中，什么是回表，什么是覆盖索引，索引下推？）、https://blog.csdn.net/demored/article/details/123067992（MySQL回表、覆盖索引、前缀索引、索引下推详解）</p>
<h2 id="全文索引">全文索引</h2>
<p>like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</p>
<p>我们知道各种搜索引擎，他们的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理跟他们差不多。</p>
<p>注意：只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</p>
<h3 id="版本支持">版本支持</h3>
<ul>
<li>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；</li>
<li>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;</li>
</ul>
<p>测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</p>
<h3 id="创建全文索引">创建全文索引</h3>
<ul>
<li>
<p>创建表时创建全文索引</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">table</span> <span class="nf">fulltext_test</span> <span class="p">(</span>
    <span class="n">id</span> <span class="kt">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span><span class="p">,</span>
    <span class="n">content</span> <span class="kt">text</span> <span class="k">NOT</span> <span class="no">NULL</span><span class="p">,</span>
    <span class="n">tag</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
    <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">FULLTEXT</span> <span class="k">KEY</span> <span class="nf">content_tag_fulltext</span><span class="p">(</span><span class="n">content</span><span class="p">,</span><span class="n">tag</span><span class="p">)</span>  <span class="c1">-- 创建联合全文索引列
</span><span class="c1"></span><span class="p">)</span> <span class="kp">ENGINE</span><span class="o">=</span><span class="n">MyISAM</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>在已存在的表上创建全文索引</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">fulltext</span> <span class="k">index</span> <span class="n">content_tag_fulltext</span> <span class="k">on</span> <span class="nf">fulltext_test</span><span class="p">(</span><span class="n">content</span><span class="p">,</span><span class="n">tag</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p>通过SQL语句ALTER TABLE创建全文索引</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">alter</span> <span class="k">table</span> <span class="n">fulltext_test</span> <span class="k">add</span> <span class="k">fulltext</span> <span class="k">index</span> <span class="nf">content_tag_fulltext</span><span class="p">(</span><span class="n">content</span><span class="p">,</span><span class="n">tag</span><span class="p">);</span>
</code></pre></div></li>
</ul>
<h3 id="修改全文索引">修改全文索引</h3>
<p>一般不修改，直接删掉重建</p>
<h3 id="删除全文索引">删除全文索引</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">drop</span> <span class="k">index</span> <span class="n">content_tag_fulltext</span> <span class="k">on</span> <span class="n">fulltext_test</span><span class="p">;</span> <span class="c1">-- 直接使用 DROP INDEX 删除全文索引
</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">alter</span> <span class="k">table</span> <span class="n">fulltext_test</span> <span class="k">drop</span> <span class="k">index</span> <span class="n">content_tag_fulltext</span><span class="p">;</span> <span class="c1">-- 通过 SQL 语句 ALTER TABLE 删除全文索引
</span></code></pre></div><h3 id="使用全文索引">使用全文索引</h3>
<p>和常用的模糊匹配使用 like + % 不同，全文索引有自己的语法格式，使用 match 和 against 关键字</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">fulltext_test</span> <span class="k">where</span> <span class="k">match</span><span class="p">(</span><span class="n">content</span><span class="p">,</span><span class="n">tag</span><span class="p">)</span> <span class="nf">against</span><span class="p">(</span><span class="s1">&#39;xxx xxx&#39;</span><span class="p">);</span>
</code></pre></div><p><strong>注意：</strong> match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错，无法使用全文索引，这是因为全文索引不会记录关键字来自哪一列。如果想要对某一列使用全文索引，请单独为该列创建全文索引。</p>
<p>有了上面的知识，就可以测试一下全文索引了。</p>
<p>首先创建测试表，插入测试数据</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">table</span> <span class="nf">test</span> <span class="p">(</span>
    <span class="n">id</span> <span class="kt">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">unsigned</span> <span class="k">not</span> <span class="no">null</span> <span class="kp">auto_increment</span><span class="p">,</span>
    <span class="n">content</span> <span class="kt">text</span> <span class="k">not</span> <span class="no">null</span><span class="p">,</span>
    <span class="k">primary</span> <span class="k">key</span><span class="p">(</span><span class="n">id</span><span class="p">),</span>
    <span class="k">fulltext</span> <span class="k">key</span> <span class="nf">content_index</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
<span class="p">)</span> <span class="kp">engine</span><span class="o">=</span><span class="n">MyISAM</span> <span class="k">default</span> <span class="kp">charset</span><span class="o">=</span><span class="n">utf8</span><span class="p">;</span>

<span class="k">insert</span> <span class="k">into</span> <span class="nf">test</span> <span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">),(</span><span class="s1">&#39;b&#39;</span><span class="p">),(</span><span class="s1">&#39;c&#39;</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="nf">test</span> <span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;aa&#39;</span><span class="p">),(</span><span class="s1">&#39;bb&#39;</span><span class="p">),(</span><span class="s1">&#39;cc&#39;</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="nf">test</span> <span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;aaa&#39;</span><span class="p">),(</span><span class="s1">&#39;bbb&#39;</span><span class="p">),(</span><span class="s1">&#39;ccc&#39;</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="nf">test</span> <span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="s1">&#39;aaaa&#39;</span><span class="p">),(</span><span class="s1">&#39;bbbb&#39;</span><span class="p">),(</span><span class="s1">&#39;cccc&#39;</span><span class="p">);</span>
</code></pre></div><p>按照全文索引的使用语法执行下面查询</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">test</span> <span class="k">where</span> <span class="k">match</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="nf">against</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">);</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">test</span> <span class="k">where</span> <span class="k">match</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="nf">against</span><span class="p">(</span><span class="s1">&#39;aa&#39;</span><span class="p">);</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">test</span> <span class="k">where</span> <span class="k">match</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="nf">against</span><span class="p">(</span><span class="s1">&#39;aaa&#39;</span><span class="p">);</span>
</code></pre></div><p>根据我们的惯性思维，应该会显示 4 条记录才对，然而结果是 1 条记录也没有，只有在执行下面的查询时:</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">test</span> <span class="k">where</span> <span class="k">match</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="nf">against</span><span class="p">(</span><span class="s1">&#39;aaaa&#39;</span><span class="p">);</span>
</code></pre></div><p>才会搜到 aaaa 这 1 条记录。</p>
<p>为什么？这个问题有很多原因，其中最常见的就是 最小搜索长度 导致的。另外插一句，使用全文索引时，测试表里至少要有 4 条以上的记录，否则，会出现意想不到的结果。</p>
<p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。</p>
<p>这两个的默认值可以使用以下命令查看</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;%ft%&#39;</span><span class="p">;</span>
</code></pre></div><p>可以看到这两个变量在 MyISAM 和 InnoDB 两种存储引擎下的变量名和默认值</p>
<pre><code>// MyISAM
ft_min_word_len = 4;
ft_max_word_len = 84;

// InnoDB
innodb_ft_min_token_size = 3;
innodb_ft_max_token_size = 84;
</code></pre><p>可以看到最小搜索长度 MyISAM 引擎下默认是 4，InnoDB 引擎下是 3，也即，MySQL 的全文索引只会对长度大于等于 4 或者 3 的词语建立索引，而刚刚搜索的只有 <em>aaaa</em> 的长度大于等于 4。</p>
<h4 id="配置最小搜索长度">配置最小搜索长度</h4>
<p>全文索引的相关参数都无法进行动态修改，必须通过修改 MySQL 的配置文件来完成。修改最小搜索长度的值为 1，首先打开 MySQL 的配置文件 /etc/my.cnf，在 [mysqld] 的下面追加以下内容</p>
<pre><code>[mysqld]
innodb_ft_min_token_size = 1
ft_min_word_len = 1
</code></pre><p>然后重启 MySQL 服务器，并修复全文索引。注意，修改完参数以后，一定要修复下索引，不然参数不会生效。</p>
<p>两种修复方式，可以使用下面的命令修复</p>
<pre><code>repair table test quick;
</code></pre><p>或者直接删掉重新建立索引，再次执行上面的查询，<em>a、aa、aaa</em> 就都可以查出来了。</p>
<p>但是，这里还有一个问题，搜索关键字 <em>a</em> 时，为什么 <em>aa、aaa、aaaa</em> 没有出现结果中，讲这个问题之前，先说说两种全文索引。</p>
<h3 id="两种全文索引">两种全文索引</h3>
<h4 id="自然语言的全文索引">自然语言的全文索引</h4>
<p>默认情况下，或者使用 in natural language mode 修饰符时，match() 函数对文本集合执行自然语言搜索，上面的例子都是自然语言的全文索引。</p>
<p>自然语言搜索引擎将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。上面提到的，测试表中必须有 4 条以上的记录，就是这个原因。</p>
<p>这个机制也比较好理解，比如说，一个数据表存储的是一篇篇的文章，文章中的常见词、语气词等等，出现的肯定比较多，搜索这些词语就没什么意义了，需要搜索的是那些文章中有特殊意义的词，这样才能把文章区分开。</p>
<h4 id="布尔全文索引">布尔全文索引</h4>
<p>对于上面提到的问题，可以使用布尔全文索引查询来解决，使用下面的命令，<em>a、aa、aaa、aaaa</em> 就都被查询出来了。</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="n">test</span> <span class="k">where</span> <span class="k">match</span><span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="nf">against</span><span class="p">(</span><span class="s1">&#39;a*&#39;</span> <span class="k">in</span> <span class="n">boolean</span> <span class="n">mode</span><span class="p">);</span>
</code></pre></div><p>在布尔搜索中，我们可以在查询中自定义某个被搜索的词语的相关性，当编写一个布尔搜索查询时，可以通过一些前缀修饰符来定制搜索。</p>
<p>MySQL 内置的修饰符，上面查询最小搜索长度时，搜索结果 ft_boolean_syntax 变量的值就是内置的修饰符，下面简单解释几个，更多修饰符的作用可以查手册</p>
<ul>
<li>
<p><strong>+</strong> 必须包含该词</p>
</li>
<li>
<p><strong>-</strong> 必须不包含该词</p>
</li>
<li>
<p><strong>&gt;</strong> 提高该词的相关性，查询的结果靠前</p>
</li>
<li>
<p><strong>&lt;</strong> 降低该词的相关性，查询的结果靠后</p>
</li>
<li>
<p><strong>*</strong> 通配符，只能接在词后面</p>
</li>
<li>
<p><!-- raw HTML omitted -->~<!-- raw HTML omitted -->表示允许出现该单词，但是出现时相关性为负</p>
</li>
<li>
<p><strong>()</strong> 子表达式</p>
</li>
<li>
<p><strong>&quot;&quot;</strong> 匹配双引号中的字面值，全文检索引擎会将双引号中的内容按照单词分开，非单词字符不用匹配，比如“test phrase”匹配“test,phrase”</p>
</li>
<li>
<p><strong>(no operator)</strong> 表示所查询的字符是可选的，如果出现，其相关性会更高</p>
</li>
<li>
<p><strong>@distance</strong> 仅仅适用于innodb。测试两个或多个单词出现的距离是否在distance的值之内，distance的单位是单词的个数。下面的测试结果是多个单词之间最远的距离要在distance之间：</p>
<p>假设数据库article表中有这么一条记录：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>title</th>
<th>body</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>BOOLEN Tutorial</td>
<td>s1,w2,d3,a4,s5,s6,s7,s8,s9,s10,a11,c12</td>
</tr>
</tbody>
</table>
<p>执行语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="k">MATCH</span> <span class="p">(</span><span class="n">title</span> <span class="p">,</span> <span class="n">body</span><span class="p">)</span> <span class="nf">AGAINST</span> <span class="p">(</span><span class="s1">&#39;&#34;w2 a4 s9&#34; @9&#39;</span> <span class="k">IN</span> <span class="n">BOOLEAN</span> <span class="n">MODE</span><span class="p">);</span>
</code></pre></div><p>查询结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>title</th>
<th>body</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>BOOLEN Tutorial</td>
<td>s1,w2,d3,a4,s5,s6,s7,s8,s9,s10,a11,c12</td>
</tr>
</tbody>
</table>
<p>执行语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="k">MATCH</span> <span class="p">(</span><span class="n">title</span> <span class="p">,</span> <span class="n">body</span><span class="p">)</span> <span class="nf">AGAINST</span> <span class="p">(</span><span class="s1">&#39;&#34;w2 a4 s9&#34; @8&#39;</span> <span class="k">IN</span> <span class="n">BOOLEAN</span> <span class="n">MODE</span><span class="p">);</span>
</code></pre></div><p>查询结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>title</th>
<th>body</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>BOOLEN Tutorial</td>
<td>s1,w2,d3,a4,s5,s6,s7,s8,s9,s10,a11,c12</td>
</tr>
</tbody>
</table>
<p>执行语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="k">MATCH</span> <span class="p">(</span><span class="n">title</span> <span class="p">,</span> <span class="n">body</span><span class="p">)</span> <span class="nf">AGAINST</span> <span class="p">(</span><span class="s1">&#39;&#34;w2 a4 s9&#34; @7&#39;</span> <span class="k">IN</span> <span class="n">BOOLEAN</span> <span class="n">MODE</span><span class="p">);</span>
</code></pre></div><p>查询结果：</p>
<p>Empty set</p>
<p>执行语句：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="k">MATCH</span> <span class="p">(</span><span class="n">title</span> <span class="p">,</span> <span class="n">body</span><span class="p">)</span> <span class="nf">AGAINST</span> <span class="p">(</span><span class="s1">&#39;&#34;w2 a4 s9&#34; @6&#39;</span> <span class="k">IN</span> <span class="n">BOOLEAN</span> <span class="n">MODE</span><span class="p">);</span>
</code></pre></div><p>查询结果：</p>
<p>Empty set</p>
<p><strong>解释：w2 a4 s9 三个单词在“s1,w2,d3,a4,s5,s6,s7,s8,s9,s10,a11,c12”这串字符串中w2和a4距离为2，w2和s9距离为7，a4和s9距离为5，因此只需要@x中的x满足x&gt;2且x&gt;7且x&gt;5即可满足要求，即可把该条记录筛选出来。</strong></p>
</li>
</ul>
<h3 id="小结">小结</h3>
<p>MySQL 的全文索引最开始仅支持英语，因为英语的词与词之间有空格，使用空格作为分词的分隔符是很方便的。亚洲文字，比如汉语、日语、汉语等，是没有空格的，这就造成了一定的限制。不过 MySQL 5.7.6 开始，引入了一个 ngram 全文分析器来解决这个问题，并且对 MyISAM 和 InnoDB 引擎都有效。</p>
<p>事实上，MyISAM 存储引擎对全文索引的支持有很多的限制，例如表级别锁对性能的影响、数据文件的崩溃、崩溃后的恢复等，这使得 MyISAM 的全文索引对于很多的应用场景并不适合。所以，多数情况下的建议是使用别的解决方案，例如 Sphinx、Lucene 等等第三方的插件，亦或是使用 InnoDB 存储引擎的全文索引。</p>
<p><strong>几个注意点：</strong></p>
<ul>
<li>使用全文索引前，搞清楚版本支持情况；</li>
<li>全文索引比 like + % 快 N 倍，但是可能存在精度问题；</li>
<li>如果需要全文索引的是大量数据，建议先添加数据，再创建索引；</li>
<li>对于中文，可以使用 MySQL 5.7.6 之后的版本，或者第三方插件。</li>
</ul>
<h3 id="全文索引测试示例">全文索引测试示例</h3>
<p>由于建立全文索引的表的存储引擎类型必须为MyISAM</p>
<p>因此新建一个utf8 MyISAM类型的表并建立一个全文索引：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">articles</span> <span class="p">(</span>
    <span class="n">id</span> <span class="kt">INT</span> <span class="k">UNSIGNED</span> <span class="kp">AUTO_INCREMENT</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">title</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span>
    <span class="n">body</span> <span class="kt">TEXT</span><span class="p">,</span>
    <span class="k">FULLTEXT</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span><span class="n">body</span><span class="p">)</span>
<span class="p">)</span> <span class="kp">ENGINE</span><span class="o">=</span><span class="n">MyISAM</span> <span class="k">DEFAULT</span>
</code></pre></div><p>其中FULLTEXT(title, body)
给title和body这两列建立全文索引，之后检索的时候注意必须同时指定这两列。</p>
<p>给这个表添加点测试数据</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">INSERT</span> <span class="k">INTO</span> <span class="nf">articles</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span><span class="n">body</span><span class="p">)</span> <span class="k">VALUES</span>
<span class="p">(</span><span class="s1">&#39;MySQL Tutorial&#39;</span><span class="p">,</span><span class="s1">&#39;DBMS stands for DataBase ...&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;How To Use MySQL Well&#39;</span><span class="p">,</span><span class="s1">&#39;After you went through a ...&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;Optimizing MySQL&#39;</span><span class="p">,</span><span class="s1">&#39;In this tutorial we will show ...&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;1001 MySQL Tricks&#39;</span><span class="p">,</span><span class="s1">&#39;1. Never run mysqld as root. 2. ...&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;MySQL vs. YourSQL&#39;</span><span class="p">,</span><span class="s1">&#39;In the following database comparison ...&#39;</span><span class="p">),</span>
<span class="p">(</span><span class="s1">&#39;MySQL Security&#39;</span><span class="p">,</span><span class="s1">&#39;When configured properly, MySQL ...&#39;</span><span class="p">);</span>
</code></pre></div><p>全文检索测试</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">articles</span> <span class="k">WHERE</span> <span class="k">MATCH</span> <span class="p">(</span><span class="n">title</span><span class="p">,</span><span class="n">body</span><span class="p">)</span> <span class="nf">AGAINST</span> <span class="p">(</span><span class="s1">&#39;database&#39;</span><span class="p">);</span>
</code></pre></div><p>注意：</p>
<ul>
<li>
<p>MATCH (title,body) 里面的值必须是前面建立全文索引的两个字段不能少。</p>
</li>
<li>
<p>FULLTEXT用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的
INDEX 也可以。</p>
</li>
</ul>
<h2 id="空间索引spatial">空间索引spatial</h2>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">shop_info</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">id</span><span class="o">`</span> <span class="kt">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span> <span class="n">COMMENT</span> <span class="s1">&#39;id&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">shop_name</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="n">COMMENT</span> <span class="s1">&#39;门店名称&#39;</span><span class="p">,</span>
  <span class="o">`</span><span class="n">geom_point</span><span class="o">`</span> <span class="n">geometry</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="n">COMMENT</span> <span class="s1">&#39;经纬度&#39;</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span>
  <span class="k">SPATIAL</span> <span class="k">KEY</span> <span class="o">`</span><span class="n">geom_index</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">geom_point</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="kp">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span> <span class="k">DEFAULT</span> <span class="kp">CHARSET</span><span class="o">=</span><span class="n">utf8mb4</span><span class="p">;</span>
</code></pre></div><p>初始化测试数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">delimiter</span>  <span class="o">//</span>
<span class="k">CREATE</span> <span class="k">PROCEDURE</span> <span class="nf">init_shop_info</span><span class="p">()</span> 
<span class="n">BEGIN</span> 
	<span class="k">DECLARE</span> <span class="n">count</span> <span class="kt">INT</span><span class="p">;</span>
	<span class="k">DECLARE</span> <span class="n">batch</span> <span class="kt">INT</span><span class="p">;</span>
	<span class="k">DECLARE</span> <span class="n">initLong</span> <span class="kt">INT</span><span class="p">;</span>
	<span class="k">DECLARE</span> <span class="n">initLat</span> <span class="kt">INT</span><span class="p">;</span>
	<span class="kt">SET</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">SET</span> <span class="n">initLong</span> <span class="o">=</span> <span class="mi">121</span><span class="p">;</span>
	<span class="kt">SET</span> <span class="n">initLat</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>
	<span class="k">WHILE</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">5000000</span> <span class="n">DO</span>
		<span class="kt">SET</span> <span class="n">batch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">START</span> <span class="n">TRANSACTION</span><span class="p">;</span> 
		<span class="k">WHILE</span> <span class="n">batch</span> <span class="o">&lt;</span> <span class="mi">1000</span> <span class="n">DO</span>
			<span class="k">insert</span> <span class="k">into</span> <span class="nf">shop_info</span><span class="p">(</span><span class="n">shop_name</span><span class="p">,</span> <span class="n">geom_point</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="nf">concat</span><span class="p">(</span><span class="s1">&#39;shop&#39;</span><span class="p">,</span> <span class="n">count</span><span class="p">),</span> <span class="nf">Point</span><span class="p">(</span><span class="n">initLong</span> <span class="o">+</span> <span class="nf">Rand</span><span class="p">(),</span><span class="n">initLat</span> <span class="o">+</span> <span class="nf">Rand</span><span class="p">()));</span>
			<span class="kt">SET</span> <span class="n">batch</span> <span class="o">=</span> <span class="n">batch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="kt">SET</span> <span class="n">count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">END</span> <span class="k">WHILE</span><span class="p">;</span>
		<span class="n">COMMIT</span><span class="p">;</span> 
	<span class="n">END</span> <span class="k">WHILE</span><span class="p">;</span>
<span class="n">END</span> <span class="o">//</span>
<span class="n">delimiter</span> <span class="p">;</span>
<span class="k">call</span> <span class="nf">init_shop_info</span><span class="p">();</span>
</code></pre></div><p>执行SQL获取附近2KM以内的记录</p>
<p><strong>粗精度</strong></p>
<p>为了指定位置周围创建边界矩形（以便可以利用其上的空间索引），可以使用经度和纬度之间的平均距离111公里。每纬度近似111km，而每经度则超过111km。因此创建出来的边界矩形会比实际需求的边界大。</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">-- 东经121.5
</span><span class="c1"></span><span class="kt">set</span> <span class="o">@</span><span class="n">longitude</span> <span class="o">=</span> <span class="mi">121</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="c1">-- 北纬31.5
</span><span class="c1"></span><span class="kt">set</span> <span class="o">@</span><span class="n">latitude</span> <span class="o">=</span> <span class="mi">31</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="c1">-- 2KM范围内
</span><span class="c1"></span><span class="kt">set</span> <span class="o">@</span><span class="n">distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>

<span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="nf">x</span><span class="p">(</span><span class="n">geom_point</span><span class="p">)</span> <span class="n">longitude</span><span class="p">,</span> <span class="nf">y</span><span class="p">(</span><span class="n">geom_point</span><span class="p">)</span> <span class="n">latitude</span><span class="p">,</span> <span class="nf">ST_Distance_Sphere</span><span class="p">(</span><span class="nf">Point</span><span class="p">(</span><span class="o">@</span><span class="n">longitude</span><span class="p">,</span> <span class="o">@</span><span class="n">latitude</span><span class="p">),</span> <span class="n">geom_point</span><span class="p">)</span> <span class="k">as</span> <span class="n">distance</span> 
<span class="k">from</span> <span class="n">shop_info</span> 
<span class="k">where</span> <span class="nf">MBRContains</span><span class="p">(</span><span class="nf">ST_MakeEnvelope</span><span class="p">(</span>
			<span class="nf">point</span><span class="p">((</span><span class="o">@</span><span class="n">longitude</span><span class="o">+</span><span class="p">(</span><span class="o">@</span><span class="n">distance</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">111</span><span class="p">)),</span> <span class="p">(</span><span class="o">@</span><span class="n">latitude</span><span class="o">+</span><span class="p">(</span><span class="o">@</span><span class="n">distance</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">111</span><span class="p">))),</span>
			<span class="nf">point</span><span class="p">((</span><span class="o">@</span><span class="n">longitude</span><span class="o">-</span><span class="p">(</span><span class="o">@</span><span class="n">distance</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">111</span><span class="p">)),</span> <span class="p">(</span><span class="o">@</span><span class="n">latitude</span><span class="o">-</span><span class="p">(</span><span class="o">@</span><span class="n">distance</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">111</span><span class="p">))))</span>
		<span class="p">,</span> <span class="n">geom_point</span><span class="p">)</span> 
<span class="k">order</span> <span class="k">by</span> <span class="n">distance</span> <span class="k">limit</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div><p><strong>细精度</strong></p>
<p>如果需要边界矩形更精确，则可以使用<code>cos(radians(${latitude})) * 111</code>进行经度计算。示例SQL如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">-- 东经121.5
</span><span class="c1"></span><span class="kt">set</span> <span class="o">@</span><span class="n">longitude</span> <span class="o">=</span> <span class="mi">121</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="c1">-- 北纬31.5
</span><span class="c1"></span><span class="kt">set</span> <span class="o">@</span><span class="n">latitude</span> <span class="o">=</span> <span class="mi">31</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
<span class="c1">-- 2KM范围内
</span><span class="c1"></span><span class="kt">set</span> <span class="o">@</span><span class="n">distance</span> <span class="o">=</span> <span class="mi">2000</span><span class="p">;</span>

<span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="nf">x</span><span class="p">(</span><span class="n">geom_point</span><span class="p">)</span> <span class="n">longitude</span><span class="p">,</span> <span class="nf">y</span><span class="p">(</span><span class="n">geom_point</span><span class="p">)</span> <span class="n">latitude</span><span class="p">,</span> <span class="nf">ST_Distance_Sphere</span><span class="p">(</span><span class="nf">Point</span><span class="p">(</span><span class="o">@</span><span class="n">longitude</span><span class="p">,</span> <span class="o">@</span><span class="n">latitude</span><span class="p">),</span> <span class="n">geom_point</span><span class="p">)</span> <span class="k">as</span> <span class="n">distance</span> 
<span class="k">from</span> <span class="n">shop_info</span> 
<span class="k">where</span> <span class="nf">MBRContains</span><span class="p">(</span><span class="nf">ST_MakeEnvelope</span><span class="p">(</span>
			<span class="nf">point</span><span class="p">((</span><span class="o">@</span><span class="n">longitude</span><span class="o">+</span><span class="p">(</span><span class="o">@</span><span class="n">distance</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">111</span><span class="o">*</span><span class="nf">cos</span><span class="p">(</span><span class="nf">radians</span><span class="p">(</span><span class="o">@</span><span class="n">latitude</span><span class="p">)))),</span> <span class="p">(</span><span class="o">@</span><span class="n">latitude</span><span class="o">+</span><span class="p">(</span><span class="o">@</span><span class="n">distance</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">111</span><span class="p">))),</span>
			<span class="nf">point</span><span class="p">((</span><span class="o">@</span><span class="n">longitude</span><span class="o">-</span><span class="p">(</span><span class="o">@</span><span class="n">distance</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">111</span><span class="o">*</span><span class="nf">cos</span><span class="p">(</span><span class="nf">radians</span><span class="p">(</span><span class="o">@</span><span class="n">latitude</span><span class="p">)))),</span> <span class="p">(</span><span class="o">@</span><span class="n">latitude</span><span class="o">-</span><span class="p">(</span><span class="o">@</span><span class="n">distance</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">111</span><span class="p">))))</span>
		<span class="p">,</span> <span class="n">geom_point</span><span class="p">)</span> 
<span class="k">order</span> <span class="k">by</span> <span class="n">distance</span> <span class="k">limit</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div><p>注意：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-convenience-functions.html#function_st-makeenvelope">ST_MakeEnvelope</a>和<a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-convenience-functions.html#function_st-distance-sphere">ST_Distance_Sphere</a>从MYSQL 5.7.6版本开始支持</li>
<li><code>ST_Distance_Sphere</code>返回的单位为米</li>
</ul>
<h3 id="geometry类型">geometry类型</h3>
<p>当需要将多边形每个角上的坐标点存入MySQL的时候，就需要用到geometry类型了</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="o">`</span><span class="n">gim</span><span class="o">`</span> <span class="p">(</span>
  <span class="o">`</span><span class="n">path</span><span class="o">`</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span><span class="p">,</span>
  <span class="o">`</span><span class="n">box</span><span class="o">`</span> <span class="n">geometry</span> <span class="k">NOT</span> <span class="no">NULL</span><span class="p">,</span>
  <span class="k">PRIMARY</span> <span class="k">KEY</span> <span class="p">(</span><span class="o">`</span><span class="n">path</span><span class="o">`</span><span class="p">),</span>
  <span class="k">SPATIAL</span> <span class="k">KEY</span> <span class="o">`</span><span class="n">box</span><span class="o">`</span> <span class="p">(</span><span class="o">`</span><span class="n">box</span><span class="o">`</span><span class="p">)</span>
<span class="p">)</span> <span class="p">;</span>
</code></pre></div><p>插入数据</p>
<p>数据的插入和普通的数据插入一样，只是<code>geometry</code>数据需要使用<code>st_geomfromtext</code>等函数来构造，相关的文档参考在这里<a href="https://dev.mysql.com/doc/refman/5.7/en/gis-data-formats.html">gis-data-formats</a>还有这个<a href="https://dev.mysql.com/doc/refman/5.7/en/populating-spatial-columns.html">populating-spatial-columns</a>。</p>
<p>这里只展示一个简单数据插入，这里我使用的是单多边形，只有四个点（逆时针顺序），<strong>使用WKT描述几何数据</strong>。</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">insert</span> <span class="k">into</span> <span class="nf">gim</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="n">box</span><span class="p">)</span> <span class="k">values</span><span class="p">(</span><span class="s1">&#39;%s&#39;</span><span class="p">,</span><span class="nf">ST_GeomFromText</span><span class="p">(</span>
			<span class="s1">&#39;Polygon((116.18866 39.791107, 116.124115 39.791107, 116.18866 39.833679, 116.124115 39.833679, 116.18866 39.791107))&#39;</span><span class="p">));</span>
</code></pre></div><p>查询这里和普通的查询也一样，只是<code>where</code>字句后面使用空间过滤相关选项就是。
使用空间索引进行查询的相关文档在这里<a href="https://dev.mysql.com/doc/refman/5.7/en/using-spatial-indexes.html">using-spatial-indexes</a></p>
<p>MySQL的文档中只提及了<code>MBRContains</code>和<code>MBRWithin</code>两种方式，经过测试，<code>MBRIntersects</code>、<code>MBREqual</code>、<code>MBROverlaps</code>、<code>MBRTouches</code>、<code>MBRDisjoint</code>都可以使用。
<strong>SpatiaLite</strong>中有一幅关于空间检索的图，放在这里做个参考。
<strong>SpatiaLite</strong>有一篇详细介绍空间索引的文档，链接在这里http://www.gaia-gis.it/spatialite-2.1/SpatiaLite-manual.html
<img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210313134136777.png" alt="image-20210313134136777"></p>
<p>一个简单的查询示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">gim</span> <span class="k">where</span> <span class="nf">MBRContains</span><span class="p">(</span><span class="nf">st_geomfromtext</span><span class="p">(</span><span class="s1">&#39;polygon((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306))&#39;</span><span class="p">),</span><span class="n">box</span><span class="p">);</span>
</code></pre></div><p>返回结果：</p>
<pre><code>+------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| path                                                                   | box                                                                                                                     |
+------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------+
| file:///root1/åŒ—äº¬/åŒ—äº¬åˆ†åŒº/æœé˜³åŒº/æœé˜³åŒº2016/J50G004039.tif | POLYGON((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306)) |
| file:///root1/åŒ—äº¬/åŒ—äº¬åˆ†åŒº/æœé˜³åŒº/æœé˜³åŒº2005/J50G004039.tif | POLYGON((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306)) |
| file:///root1/åŒ—äº¬/åŒ—äº¬åˆ†åŒº/æœé˜³åŒº/æœé˜³åŒº2003/J50G004039.tif | POLYGON((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306)) |
| file:///root1/åŒ—äº¬/åŒ—äº¬åˆ†å¹…/J50G004039.tif                       | POLYGON((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306)) |
+------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------+
4 rows in set

</code></pre><p>其他的还可以使用<code>MBRIntersects</code>、<code>MBREqual</code>、<code>MBROverlaps</code>、<code>MBRTouches</code>、<code>MBRDisjoint</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> <span class="n">url</span> <span class="k">from</span> <span class="n">ngcc_metadata</span> <span class="k">where</span> <span class="nf">MBRIntersects</span><span class="p">(</span><span class="nf">st_geomfromtext</span><span class="p">(</span><span class="s1">&#39;polygon((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306))&#39;</span><span class="p">),</span><span class="o">`</span><span class="mi">5</span><span class="o">`</span><span class="p">);</span>

<span class="k">select</span> <span class="n">url</span> <span class="k">from</span> <span class="n">ngcc_metadata</span> <span class="k">where</span> <span class="nf">MBREqual</span><span class="p">(</span><span class="nf">st_geomfromtext</span><span class="p">(</span><span class="s1">&#39;polygon((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306))&#39;</span><span class="p">),</span><span class="o">`</span><span class="mi">5</span><span class="o">`</span><span class="p">);</span>

<span class="k">select</span> <span class="n">url</span> <span class="k">from</span> <span class="n">ngcc_metadata</span> <span class="k">where</span> <span class="nf">MBROverlaps</span><span class="p">(</span><span class="nf">st_geomfromtext</span><span class="p">(</span><span class="s1">&#39;polygon((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306))&#39;</span><span class="p">),</span><span class="o">`</span><span class="mi">5</span><span class="o">`</span><span class="p">);</span>

<span class="k">select</span> <span class="n">url</span> <span class="k">from</span> <span class="n">ngcc_metadata</span> <span class="k">where</span> <span class="nf">MBRTouches</span><span class="p">(</span><span class="nf">st_geomfromtext</span><span class="p">(</span><span class="s1">&#39;polygon((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306))&#39;</span><span class="p">),</span><span class="o">`</span><span class="mi">5</span><span class="o">`</span><span class="p">);</span>

<span class="k">select</span> <span class="n">url</span> <span class="k">from</span> <span class="n">ngcc_metadata</span> <span class="k">where</span> <span class="nf">MBRDisjoint</span><span class="p">(</span><span class="nf">st_geomfromtext</span><span class="p">(</span><span class="s1">&#39;polygon((116.438599 39.832306, 116.374054 39.832306, 116.438599 39.876251, 116.374054 39.876251, 116.438599 39.832306))&#39;</span><span class="p">),</span><span class="o">`</span><span class="mi">5</span><span class="o">`</span><span class="p">);</span>
</code></pre></div><p>更多的或者更具体的使用方法请参考官方文档</p>
<h2 id="索引中的visible与invisible">索引中的visible与invisible</h2>
<p>参考博客：https://blog.csdn.net/zhizhengguan/article/details/87276163</p>
<h2 id="mysql查询某个表的字段名">mysql查询某个表的字段名</h2>
<h3 id="描述表字段信息">描述表字段信息</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">DESC</span> <span class="n">TableName</span><span class="p">;</span>
</code></pre></div><h3 id="查表字段及其信息">查表字段及其信息</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SHOW</span> <span class="n">COLUMNS</span> <span class="k">FROM</span> <span class="n">TableName</span><span class="p">;</span>
</code></pre></div><h3 id="information_schema库详解存放mysql的元数据">information_schema库详解（存放MySQL的元数据）</h3>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">SCHEMATA</span> <span class="c1"># 提供了关于数据库的信息。
</span><span class="c1"></span><span class="kp">TABLES</span>  <span class="c1"># 给出了关于数据库中的表的信息。
</span><span class="c1"></span><span class="n">COLUMNS</span> <span class="c1"># 给出了表中的列信息。
</span><span class="c1"></span><span class="n">STATISTICS</span> <span class="c1"># 给出了关于表索引的信息。
</span><span class="c1"></span><span class="n">USER_PRIVILEGES</span> <span class="c1"># 给出了关于全程权限的信息。该信息源自mysql.user授权表。
</span><span class="c1"></span><span class="n">SCHEMA_PRIVILEGES</span> <span class="c1"># 给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。
</span><span class="c1"></span><span class="n">TABLE_PRIVILEGES</span> <span class="c1"># 给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。
</span><span class="c1"></span><span class="n">COLUMN_PRIVILEGES</span> <span class="c1"># 给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。
</span><span class="c1"></span><span class="n">CHARACTER_SETS</span> <span class="c1"># 提供了关于可用字符集的信息。
</span><span class="c1"></span><span class="n">COLLATIONS</span> <span class="c1"># 提供了关于各字符集的对照信息。
</span><span class="c1"></span><span class="n">COLLATION_CHARACTER_SET_APPLICABILITY</span> <span class="c1"># 指明了可用于校对的字符集。
</span><span class="c1"></span><span class="n">TABLE_CONSTRAINTS</span> <span class="c1"># 描述了存在约束的表。
</span><span class="c1"></span><span class="n">KEY_COLUMN_USAGE</span> <span class="c1"># 描述了具有约束的键列。
</span><span class="c1"></span><span class="n">ROUTINES</span> <span class="c1"># 提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。
</span><span class="c1"></span><span class="n">VIEWS</span> <span class="c1"># 给出了关于数据库中的视图的信息。
</span><span class="c1"></span><span class="n">TRIGGERS</span> <span class="c1"># 提供了关于触发程序的信息。
</span></code></pre></div><p>用法实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">-- 比方说USER_PRIVILEGES
</span><span class="c1"></span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">USER_PRIVILEGES</span><span class="p">;</span>
</code></pre></div><p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210313123233459.png" alt="image-20210313123233459"></p>
<h4 id="查字段">查字段</h4>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> 
	<span class="n">COLUMN_NAME</span> 
<span class="k">from</span> 
	<span class="n">information_schema</span><span class="p">.</span><span class="n">COLUMNS</span> 
<span class="k">where</span> <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&#34;TableName&#34;</span> <span class="k">and</span> <span class="n">table_schema</span> <span class="o">=</span> <span class="s2">&#34;DatabaseName&#34;</span><span class="p">;</span>
</code></pre></div><h4 id="查看字段详细信息">查看字段详细信息</h4>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span>
  <span class="n">COLUMN_NAME</span> <span class="s2">&#34;字段名称&#34;</span><span class="p">,</span>
  <span class="n">COLUMN_TYPE</span> <span class="s2">&#34;字段类型长度&#34;</span><span class="p">,</span>
  <span class="k">IF</span><span class="p">(</span><span class="n">EXTRA</span><span class="o">=</span><span class="s2">&#34;auto_increment&#34;</span><span class="p">,</span><span class="nf">CONCAT</span><span class="p">(</span><span class="n">COLUMN_KEY</span><span class="p">,</span><span class="s2">&#34;(&#34;</span><span class="p">,</span> <span class="k">IF</span><span class="p">(</span><span class="n">EXTRA</span><span class="o">=</span><span class="s2">&#34;auto_increment&#34;</span><span class="p">,</span><span class="s2">&#34;自增长&#34;</span><span class="p">,</span><span class="n">EXTRA</span><span class="p">),</span><span class="s2">&#34;)&#34;</span><span class="p">),</span><span class="n">COLUMN_KEY</span><span class="p">)</span> <span class="s2">&#34;主外键&#34;</span><span class="p">,</span>
  <span class="n">IS_NULLABLE</span> <span class="s2">&#34;空标识&#34;</span><span class="p">,</span>
  <span class="n">COLUMN_COMMENT</span> <span class="s2">&#34;字段说明&#34;</span>
<span class="k">FROM</span>
    <span class="n">information_schema</span><span class="p">.</span> <span class="n">COLUMNS</span>
<span class="k">WHERE</span> <span class="n">TABLE_SCHEMA</span> <span class="o">=</span> <span class="s2">&#34;DatabaseName&#34;</span> <span class="k">AND</span> <span class="n">TABLE_NAME</span> <span class="o">=</span> <span class="s2">&#34;TableName&#34;</span><span class="p">;</span>
</code></pre></div><h4 id="查询字段个数">查询字段个数</h4>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">select</span> 
	<span class="nf">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="k">from</span> 
	<span class="n">information_schema</span><span class="p">.</span><span class="n">COLUMNS</span> 
<span class="k">where</span> <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&#34;TableName&#34;</span> <span class="k">and</span> <span class="n">table_schema</span> <span class="o">=</span> <span class="s2">&#34;DatabaseName&#34;</span><span class="p">;</span>
</code></pre></div><h4 id="查询某字段所在行数">查询某字段所在行数</h4>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="kt">set</span> <span class="o">@</span><span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="p">(</span>
	<span class="k">select</span> <span class="o">@</span><span class="n">temp</span><span class="p">:</span><span class="o">=@</span><span class="n">temp</span><span class="o">+</span><span class="mi">1</span> <span class="k">as</span> <span class="n">new_id</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="n">COLUMN_NAME</span> <span class="k">as</span> <span class="n">col_name</span> <span class="k">from</span><span class="p">(</span>
		<span class="k">select</span> 
        	<span class="n">COLUMN_NAME</span> 
        <span class="k">from</span> 
        	<span class="n">information_schema</span><span class="p">.</span><span class="n">COLUMNS</span>
        <span class="k">where</span> 
        	<span class="n">table_schema</span><span class="o">=</span><span class="s2">&#34;DatabaseName&#34;</span> <span class="k">and</span> <span class="n">table_name</span><span class="o">=</span><span class="s2">&#34;TableName&#34;</span>
    <span class="p">)</span> <span class="n">t</span>
<span class="p">)</span> <span class="n">t</span>
<span class="k">where</span> <span class="n">col_name</span><span class="o">=</span><span class="s2">&#34;需要查询的字段的名称&#34;</span><span class="p">;</span>
</code></pre></div><h4 id="处理成插入的字段">处理成插入的字段</h4>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">-- 一列，逗号在前
</span><span class="c1"></span><span class="kt">SET</span> <span class="o">@</span><span class="n">mytemp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">SELECT</span> 
    <span class="p">(</span><span class="k">CASE</span> <span class="n">t</span><span class="p">.</span><span class="n">newid</span> 
            <span class="k">WHEN</span> <span class="mi">1</span>
            <span class="k">THEN</span> <span class="nf">CONCAT</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span><span class="n">COLUMN_NAME</span><span class="p">)</span>
            <span class="k">ELSE</span> <span class="nf">CONCAT</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="n">COLUMN_NAME</span><span class="p">)</span>
            <span class="n">END</span> 
    <span class="p">)</span><span class="n">COLUMN_NAME</span>
<span class="c1">--   t.newid,t.COLUMN_NAME
</span><span class="c1"></span><span class="k">FROM</span> <span class="p">(</span>
    
    <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="p">(</span>
        <span class="k">SELECT</span> <span class="p">(</span><span class="o">@</span><span class="n">mytemp</span><span class="p">:</span><span class="o">=@</span><span class="n">mytemp</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="n">newid</span><span class="p">,</span><span class="n">t</span><span class="p">.</span><span class="n">COLUMN_NAME</span> <span class="k">FROM</span> 
            <span class="p">(</span>
                <span class="k">SELECT</span>
                    <span class="n">COLUMN_NAME</span>                
                <span class="k">FROM</span>
                    <span class="n">information_schema</span><span class="p">.</span><span class="n">COLUMNS</span>
                <span class="k">WHERE</span>
                    <span class="n">TABLE_SCHEMA</span> <span class="o">=</span> <span class="s1">&#39;DatabaseName&#39;</span>
                <span class="k">AND</span> <span class="n">TABLE_NAME</span> <span class="o">=</span> <span class="s1">&#39;TableName&#39;</span>
            <span class="p">)</span><span class="n">t</span>
    <span class="p">)</span> <span class="n">t</span>
<span class="p">)</span><span class="n">t</span>

<span class="c1">-- 用分组的方法（一行）
</span><span class="c1"></span><span class="k">SELECT</span>
    <span class="nf">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="n">count_num</span><span class="p">,</span><span class="nf">GROUP_CONCAT</span><span class="p">(</span><span class="n">COLUMN_NAME</span><span class="p">)</span>        
<span class="k">FROM</span>
    <span class="n">information_schema</span><span class="p">.</span><span class="n">COLUMNS</span>
<span class="k">WHERE</span>
    <span class="n">TABLE_SCHEMA</span> <span class="o">=</span> <span class="s1">&#39;DatabaseName&#39;</span>
<span class="k">AND</span> <span class="n">TABLE_NAME</span> <span class="o">=</span> <span class="s1">&#39;TableName&#39;</span>
</code></pre></div><p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210313122301028.png" alt="image-20210313122301028"></p>
<h4 id="查询某个库除了主键以外的约束">查询某个库除了主键以外的约束</h4>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span>
    <span class="n">TABLE_NAME</span> <span class="s1">&#39;表名&#39;</span><span class="p">,</span>
    <span class="n">COLUMN_NAME</span> <span class="s1">&#39;字段名&#39;</span><span class="p">,</span>
    <span class="n">CONSTRAINT_NAME</span> <span class="s1">&#39;约束名&#39;</span><span class="p">,</span>
    <span class="n">REFERENCED_TABLE_NAME</span> <span class="s1">&#39;父表名&#39;</span><span class="p">,</span>
    <span class="n">REFERENCED_COLUMN_NAME</span>  <span class="s1">&#39;父表字段名&#39;</span>
<span class="k">FROM</span>
    <span class="n">INFORMATION_SCHEMA</span><span class="p">.</span><span class="n">KEY_COLUMN_USAGE</span>
    <span class="k">WHERE</span>
    <span class="n">TABLE_SCHEMA</span> <span class="o">=</span> <span class="s1">&#39;net_management&#39;</span> 
    <span class="k">AND</span> <span class="n">CONSTRAINT_name</span> <span class="o">!=</span> <span class="s1">&#39;PRIMARY&#39;</span><span class="p">;</span>
</code></pre></div><p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210313122521004.png" alt="image-20210313122521004"></p>
<h4 id="查询某个库的约束和约束类型">查询某个库的约束和约束类型</h4>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span>
    <span class="n">kcu</span><span class="p">.</span><span class="n">CONSTRAINT_NAME</span> <span class="s1">&#39;约束名称&#39;</span><span class="p">,</span>
    <span class="k">LEFT</span><span class="p">(</span><span class="n">tc</span><span class="p">.</span><span class="n">CONSTRAINT_TYPE</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="s1">&#39;约束类型&#39;</span><span class="p">,</span>
    <span class="n">kcu</span><span class="p">.</span><span class="n">TABLE_SCHEMA</span> <span class="s1">&#39;子库&#39;</span><span class="p">,</span>
    <span class="n">kcu</span><span class="p">.</span><span class="n">TABLE_NAME</span> <span class="s1">&#39;子表&#39;</span><span class="p">,</span>
    <span class="n">kcu</span><span class="p">.</span><span class="n">COLUMN_NAME</span> <span class="s1">&#39;子表字段&#39;</span><span class="p">,</span>
    <span class="n">kcu</span><span class="p">.</span><span class="n">REFERENCED_TABLE_NAME</span> <span class="s1">&#39;父库&#39;</span><span class="p">,</span>
    <span class="n">kcu</span><span class="p">.</span><span class="n">REFERENCED_TABLE_SCHEMA</span> <span class="s1">&#39;父表&#39;</span><span class="p">,</span>
    <span class="n">kcu</span><span class="p">.</span><span class="n">REFERENCED_COLUMN_NAME</span> <span class="s1">&#39;父表字段&#39;</span>
<span class="k">FROM</span>
    <span class="n">information_schema</span><span class="p">.</span><span class="n">KEY_COLUMN_USAGE</span> <span class="n">kcu</span> 
<span class="k">LEFT</span> <span class="k">JOIN</span>     
   <span class="n">information_schema</span><span class="p">.</span><span class="o">`</span><span class="n">TABLE_CONSTRAINTS</span><span class="o">`</span> <span class="n">tc</span>
   <span class="k">ON</span> <span class="n">kcu</span><span class="p">.</span><span class="n">TABLE_SCHEMA</span> <span class="o">=</span> <span class="n">tc</span><span class="p">.</span><span class="n">TABLE_SCHEMA</span> 
   <span class="k">AND</span> <span class="n">kcu</span><span class="p">.</span><span class="n">TABLE_NAME</span> <span class="o">=</span> <span class="n">tc</span><span class="p">.</span><span class="n">TABLE_NAME</span>
   <span class="k">AND</span> <span class="n">kcu</span><span class="p">.</span><span class="n">CONSTRAINT_NAME</span> <span class="o">=</span> <span class="n">tc</span><span class="p">.</span><span class="n">CONSTRAINT_NAME</span>
<span class="k">WHERE</span>
   <span class="n">kcu</span><span class="p">.</span><span class="n">TABLE_SCHEMA</span> <span class="o">=</span> <span class="s1">&#39;zx_public&#39;</span>  
   <span class="c1">-- AND kcu.CONSTRAINT_NAME!=&#39;PRIMARY&#39;
</span><span class="c1"></span>   <span class="c1">-- AND kcu.TABLE_NAME = &#39;res_site&#39;
</span><span class="c1"></span><span class="k">ORDER</span> <span class="k">BY</span> <span class="n">kcu</span><span class="p">.</span><span class="n">TABLE_SCHEMA</span><span class="p">,</span><span class="n">kcu</span><span class="p">.</span><span class="n">TABLE_NAME</span><span class="p">,</span><span class="n">tc</span><span class="p">.</span><span class="n">CONSTRAINT_TYPE</span><span class="p">;</span>
</code></pre></div><p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210313122848369.png" alt="image-20210313122848369"></p>
<h2 id="maxvalue关键字">MAXVALUE关键字</h2>
<p>代表一个比最大可能的integer的值还要大的数值，用数学语言来讲就是数值的最大上界</p>
<p>常被用于MySQL范围分区中</p>
<h2 id="mysql分区partition功能">MySQL分区（partition）功能</h2>
<p>= 水平分区（根据列属性按行分） =</p>
<p>举个例子：一个包含十年发票记录的表可以被分区为十个不同的分区，每个分区包含的是其中一年的记录</p>
<p><strong>水平分区的模式</strong></p>
<ul>
<li>Range（范围）- 这种模式允许DBA将数据划分不同范围。例如DBA可以将一个表通过年份划分成三个分区，比如：80年代的数据，90年代的数据以及任何在2000年（包括2000年）后的数据</li>
<li>Hash（哈希）- 这种模式允许DBA通过对表的一个或多个列的Hash Key进行计算，最后通过这个Hash码不同数值对应的数据区域进行分区，比如DBA可以建立一个对表主键进行分区的表</li>
<li>Key（键值）- Hash模式的一种延伸，这里的Hash Key是MySQL系统产生的</li>
<li>List（预定义列表）- 这种模式允许系统通过DBA定义的列表的值所对应的行数据进行分割，比如：DBA建立了一个横跨三个分区的表，分别根据2004年2005年和2006年值所对应的数据</li>
<li>Composite（复合模式）- 其实就是以上模式的组合使用，比如：在初始化已经进行了Range范围分区的表上，我们可以对其中一个分区再进行hash哈希分区</li>
</ul>
<p><strong>垂直分区（按列分）</strong></p>
<p>举个例子：一个包含了大text和BLOB列的表，这些text和BLOB列不经常被访问，这时候就要把这些不经常使用的text和BLOB划分到另一个分区，在保证它们数据相关性的同时还能提高访问的速度</p>
<p><strong>分区的优点</strong></p>
<ul>
<li>可以提高数据库的性能</li>
<li>对大表（行较多）的维护更快、更容易，因为数据分布在不同的逻辑文件上</li>
<li>删除分区或它的数据是容易的，因为它不影响其他表</li>
</ul>
<p>注意：pruning，即截断。意思是说当你查询时，只扫描所需要查询的分区，其他部分不会扫描，这就大大提高了性能</p>
<h3 id="分区表和未分区表试验过程">分区表和未分区表试验过程</h3>
<p><strong>创建分区表，按日期的年份拆分</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">part_tab</span> <span class="p">(</span> <span class="n">c1</span> <span class="kt">int</span> <span class="k">default</span> <span class="no">NULL</span><span class="p">,</span>  <span class="n">c2</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">default</span> <span class="no">NULL</span><span class="p">,</span>  <span class="n">c3</span> <span class="kt">date</span> <span class="k">default</span> <span class="no">NULL</span><span class="p">)</span> <span class="kp">engine</span><span class="o">=</span><span class="n">myisam</span> 
<span class="n">PARTITION</span> <span class="k">BY</span> <span class="nf">RANGE</span> <span class="p">(</span><span class="kt">year</span><span class="p">(</span><span class="n">c3</span><span class="p">))</span> 
<span class="p">(</span><span class="n">PARTITION</span> <span class="n">p0</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">1995</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p1</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">1996</span><span class="p">)</span> <span class="p">,</span> 
<span class="n">PARTITION</span> <span class="n">p2</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">1997</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p3</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">1998</span><span class="p">)</span> <span class="p">,</span> 
<span class="n">PARTITION</span> <span class="n">p4</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">1999</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p5</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">2000</span><span class="p">)</span> <span class="p">,</span> 
<span class="n">PARTITION</span> <span class="n">p6</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">2001</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p7</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">2002</span><span class="p">)</span> <span class="p">,</span> 
<span class="n">PARTITION</span> <span class="n">p8</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">2003</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p9</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">2004</span><span class="p">)</span> <span class="p">,</span> 
<span class="n">PARTITION</span> <span class="n">p10</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">2010</span><span class="p">),</span> <span class="n">PARTITION</span> <span class="n">p11</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="n">THAN</span> <span class="n">MAXVALUE</span> <span class="p">);</span>
</code></pre></div><p>注意到最后一行，考虑到可能的最大值</p>
<p><strong>创建未分区表</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">table</span> <span class="nf">no_part_tab</span> <span class="p">(</span>
    <span class="n">c1</span> <span class="kt">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">default</span> <span class="no">NULL</span><span class="p">,</span>
    <span class="n">c2</span> <span class="kt">varchar</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">default</span> <span class="no">NULL</span><span class="p">,</span>
    <span class="n">c3</span> <span class="kt">date</span> <span class="k">default</span> <span class="no">NULL</span>
<span class="p">)</span> <span class="kp">engine</span><span class="o">=</span><span class="n">myisam</span><span class="p">;</span>
</code></pre></div><p>通过存储过程灌入800万数据到两个表中，然后测试性能发现分区的表执行了0.5秒，未分区的执行了4.7秒，使用explain来分析执行的情况：</p>
<pre><code>id: 1
select_type: SIMPLE
table: no_part_tab          #未分区的表的表名
type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
rows: 8000000               #需要查询800万条记录
Extra: Using where
</code></pre><pre><code>id: 1
select_type: SIMPLE
table: part_tab             #分区的表的表名
type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
rows: 798458               #只需要查询798458条记录
Extra: Using where
</code></pre><p><strong>试验创建索引后情况</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">create</span> <span class="k">index</span> <span class="n">idx_of_c3</span> <span class="k">on</span> <span class="nf">no_part_tab</span> <span class="p">(</span><span class="n">c3</span><span class="p">);</span>
<span class="k">create</span> <span class="k">index</span> <span class="n">idx_of_c3</span> <span class="k">on</span> <span class="nf">part_tab</span> <span class="p">(</span><span class="n">c3</span><span class="p">);</span>
</code></pre></div><p>创建索引后的数据库文件大小列表：</p>
<pre><code>2008-05-24 09:23             8,608 no_part_tab.frm
2008-05-24 09:24       255,999,996 no_part_tab.MYD
2008-05-24 09:24        81,611,776 no_part_tab.MYI
2008-05-24 09:25                 0 part_tab#P#p0.MYD
2008-05-24 09:26             1,024 part_tab#P#p0.MYI
2008-05-24 09:26        25,550,656 part_tab#P#p1.MYD
2008-05-24 09:26         8,148,992 part_tab#P#p1.MYI
2008-05-24 09:26        25,620,192 part_tab#P#p10.MYD
2008-05-24 09:26         8,170,496 part_tab#P#p10.MYI
2008-05-24 09:25                 0 part_tab#P#p11.MYD
2008-05-24 09:26             1,024 part_tab#P#p11.MYI
2008-05-24 09:26        25,656,512 part_tab#P#p2.MYD
2008-05-24 09:26         8,181,760 part_tab#P#p2.MYI
2008-05-24 09:26        25,586,880 part_tab#P#p3.MYD
2008-05-24 09:26         8,160,256 part_tab#P#p3.MYI
2008-05-24 09:26        25,585,696 part_tab#P#p4.MYD
2008-05-24 09:26         8,159,232 part_tab#P#p4.MYI
2008-05-24 09:26        25,585,216 part_tab#P#p5.MYD
2008-05-24 09:26         8,159,232 part_tab#P#p5.MYI
2008-05-24 09:26        25,655,740 part_tab#P#p6.MYD
2008-05-24 09:26         8,181,760 part_tab#P#p6.MYI
2008-05-24 09:26        25,586,528 part_tab#P#p7.MYD
2008-05-24 09:26         8,160,256 part_tab#P#p7.MYI
2008-05-24 09:26        25,586,752 part_tab#P#p8.MYD
2008-05-24 09:26         8,160,256 part_tab#P#p8.MYI
2008-05-24 09:26        25,585,824 part_tab#P#p9.MYD
2008-05-24 09:26         8,159,232 part_tab#P#p9.MYI
2008-05-24 09:25             8,608 part_tab.frm
2008-05-24 09:25                68 part_tab.par
</code></pre><p>再次测试性能发现分区的表执行了0.86秒，未分区的执行了2.42秒</p>
<p>增加未索引字段查询之后分区的表执行了0.75秒，未分区的执行了11.5秒</p>
<h4 id="结论">结论</h4>
<p><strong>初步结论</strong></p>
<ul>
<li>分区和未分区占用文件空间大致相同（数据和索引文件）</li>
<li>如果查询语句中有未建立索引字段，分区时间远远优于未分区时间</li>
<li>如果查询语句中字段建立了索引，分区和未分区的差别缩小，分区略优于未分区</li>
</ul>
<p><strong>最终结论</strong></p>
<ul>
<li>对于大数据量，建议使用分区功能</li>
<li>应去除不必要的字段</li>
<li>根据手册，增加myisam_max_sort_file_size（MySQL重建索引时允许使用的临时文件最大大小）会增加分区的性能</li>
</ul>
<h3 id="分区命令详解">分区命令详解</h3>
<p><strong>RANGE类型</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">users</span> <span class="p">(</span>
       <span class="n">uid</span> <span class="kt">INT</span> <span class="k">UNSIGNED</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
       <span class="n">name</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
       <span class="n">email</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span>
<span class="p">)</span>
<span class="n">PARTITION</span> <span class="k">BY</span> <span class="nf">RANGE</span> <span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="p">(</span>
       <span class="n">PARTITION</span> <span class="n">p0</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">3000000</span><span class="p">)</span>
       <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data0/data&#39;</span>
       <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data1/idx&#39;</span><span class="p">,</span>
 
       <span class="n">PARTITION</span> <span class="n">p1</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">6000000</span><span class="p">)</span>
       <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data2/data&#39;</span>
       <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data3/idx&#39;</span><span class="p">,</span>
 
       <span class="n">PARTITION</span> <span class="n">p2</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">9000000</span><span class="p">)</span>
       <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data4/data&#39;</span>
       <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data5/idx&#39;</span><span class="p">,</span>
 
       <span class="n">PARTITION</span> <span class="n">p3</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="n">THAN</span> <span class="n">MAXVALUE</span>    
       <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data6/data&#39;</span> 
       <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data7/idx&#39;</span>
<span class="p">);</span>
</code></pre></div><p>在这里，将用户表分成4个分区，以每300万条记录为界限，每个分区都有自己独立的数据、索引文件的存放目录，与此同时，这些目录所在的物理磁盘分区可能也都是完全独立的，可以提高磁盘IO吞吐量</p>
<p><strong>LIST类型</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">category</span> <span class="p">(</span>
     <span class="n">cid</span> <span class="kt">INT</span> <span class="k">UNSIGNED</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
     <span class="n">name</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span>
<span class="p">)</span>
<span class="n">PARTITION</span> <span class="k">BY</span> <span class="nf">LIST</span> <span class="p">(</span><span class="n">cid</span><span class="p">)</span> <span class="p">(</span>
     <span class="n">PARTITION</span> <span class="n">p0</span> <span class="k">VALUES</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">12</span><span class="p">)</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data0/data&#39;</span> 
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data1/idx&#39;</span><span class="p">,</span>
     
     <span class="n">PARTITION</span> <span class="n">p1</span> <span class="k">VALUES</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data2/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data3/idx&#39;</span><span class="p">,</span>
     
     <span class="n">PARTITION</span> <span class="n">p2</span> <span class="k">VALUES</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">14</span><span class="p">)</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data4/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data5/idx&#39;</span><span class="p">,</span>
     
     <span class="n">PARTITION</span> <span class="n">p3</span> <span class="k">VALUES</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">15</span><span class="p">)</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data6/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data7/idx&#39;</span>
<span class="p">);</span>
</code></pre></div><p>分成4个区，数据文件和索引文件单独存放</p>
<p><strong>HASH类型</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">users</span> <span class="p">(</span>
     <span class="n">uid</span> <span class="kt">INT</span> <span class="k">UNSIGNED</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
     <span class="n">name</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
     <span class="n">email</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span>
<span class="p">)</span>
<span class="n">PARTITION</span> <span class="k">BY</span> <span class="nf">HASH</span> <span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="n">PARTITIONS</span> <span class="mi">4</span> <span class="p">(</span>
     <span class="n">PARTITION</span> <span class="n">p0</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data0/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data1/idx&#39;</span><span class="p">,</span>
 
     <span class="n">PARTITION</span> <span class="n">p1</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data2/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data3/idx&#39;</span><span class="p">,</span>
 
     <span class="n">PARTITION</span> <span class="n">p2</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data4/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data5/idx&#39;</span><span class="p">,</span>
 
     <span class="n">PARTITION</span> <span class="n">p3</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data6/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data7/idx&#39;</span>
<span class="p">);</span>
</code></pre></div><p><strong>KEY类型</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">users</span> <span class="p">(</span>
     <span class="n">uid</span> <span class="kt">INT</span> <span class="k">UNSIGNED</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
     <span class="n">name</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
     <span class="n">email</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span>
<span class="p">)</span>
<span class="n">PARTITION</span> <span class="k">BY</span> <span class="k">KEY</span> <span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="n">PARTITIONS</span> <span class="mi">4</span> <span class="p">(</span>
     <span class="n">PARTITION</span> <span class="n">p0</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data0/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data1/idx&#39;</span><span class="p">,</span>
     
     <span class="n">PARTITION</span> <span class="n">p1</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data2/data&#39;</span> 
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data3/idx&#39;</span><span class="p">,</span>
     
     <span class="n">PARTITION</span> <span class="n">p2</span> 
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data4/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data5/idx&#39;</span><span class="p">,</span>
     
     <span class="n">PARTITION</span> <span class="n">p3</span> 
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data6/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data7/idx&#39;</span>
<span class="p">);</span>
</code></pre></div><p>分成4个区，数据文件和索引文件单独存放</p>
<p><strong>子分区</strong></p>
<p>子分区是针对RANGE/LIST类型的分区表中每个分区的再次分割。再次分割可以是HASH/KEY等类型。</p>
<p>对RANGE分区再次进行子分区划分，子分区采用HASH类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">users</span> <span class="p">(</span>
     <span class="n">uid</span> <span class="kt">INT</span> <span class="k">UNSIGNED</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
     <span class="n">name</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
     <span class="n">email</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span>
<span class="p">)</span>
<span class="n">PARTITION</span> <span class="k">BY</span> <span class="nf">RANGE</span> <span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="n">SUBPARTITION</span> <span class="k">BY</span> <span class="nf">HASH</span> <span class="p">(</span><span class="n">uid</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span> <span class="n">SUBPARTITIONS</span> <span class="mi">2</span><span class="p">(</span>
     <span class="n">PARTITION</span> <span class="n">p0</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">3000000</span><span class="p">)</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data0/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data1/idx&#39;</span><span class="p">,</span>
 
     <span class="n">PARTITION</span> <span class="n">p1</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">6000000</span><span class="p">)</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data2/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data3/idx&#39;</span>
<span class="p">);</span>
</code></pre></div><p>或者</p>
<p>对RANGE分区再次进行子分区划分，子分区采用KEY类型：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="nf">users</span> <span class="p">(</span>
     <span class="n">uid</span> <span class="kt">INT</span> <span class="k">UNSIGNED</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="kp">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
     <span class="n">name</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
     <span class="n">email</span> <span class="kt">VARCHAR</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="k">NOT</span> <span class="no">NULL</span> <span class="k">DEFAULT</span> <span class="s1">&#39;&#39;</span>
<span class="p">)</span>
<span class="n">PARTITION</span> <span class="k">BY</span> <span class="nf">RANGE</span> <span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="n">SUBPARTITION</span> <span class="k">BY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">uid</span><span class="p">)</span> <span class="n">SUBPARTITIONS</span> <span class="mi">2</span><span class="p">(</span>
     <span class="n">PARTITION</span> <span class="n">p0</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">3000000</span><span class="p">)</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data0/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data1/idx&#39;</span><span class="p">,</span>
 
     <span class="n">PARTITION</span> <span class="n">p1</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">6000000</span><span class="p">)</span>
     <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data2/data&#39;</span>
     <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data3/idx&#39;</span>
<span class="p">);</span>
</code></pre></div><h3 id="分区管理">分区管理</h3>
<p><strong>获取分区信息</strong></p>
<p>MySQL可以通过如下方式来获取分区表的信息：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">show</span> <span class="k">create</span> <span class="k">table</span> <span class="n">tbl_name</span><span class="p">;</span> <span class="c1">-- 表详细结构 --
</span><span class="c1"></span><span class="k">show</span> <span class="k">table</span> <span class="n">status</span><span class="p">;</span> <span class="c1">-- 表的各种参数状态 --
</span><span class="c1"></span><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">information_schema</span><span class="p">.</span><span class="n">partitions</span><span class="p">;</span> <span class="c1">-- 通过数据字典来查看表的分区信息 --
</span><span class="c1"></span><span class="k">explain</span> <span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">tbl_name</span><span class="p">;</span> <span class="c1">-- 通过此语句查到若干信息，里面有一个partitions能显示扫描哪些分区，结合其他字段我们能知道它们的使用情况 --
</span></code></pre></div><p><strong>删除分区</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">tbl_name</span> <span class="k">DROP</span> <span class="n">PARTITION</span> <span class="n">p0</span><span class="p">;</span> <span class="c1">#删除分区 p0
</span></code></pre></div><p><strong>删除所有分区</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">tbl_name</span> <span class="n">REMOVE</span> <span class="n">PARTITIONING</span><span class="p">;</span>
</code></pre></div><p><strong>重建分区</strong></p>
<ul>
<li>
<p>RANGE分区重建</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="n">REORGANIZE</span> <span class="n">PARTITION</span> <span class="n">p0</span><span class="p">,</span><span class="n">p1</span> <span class="k">INTO</span> <span class="p">(</span><span class="n">PARTITION</span> <span class="n">p0</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">6000000</span><span class="p">));</span>  <span class="c1">#将原来的 p0,p1 分区合并起来，放到新的 p0 分区中。
</span></code></pre></div></li>
<li>
<p>LIST分区重建</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="n">REORGANIZE</span> <span class="n">PARTITION</span> <span class="n">p0</span><span class="p">,</span><span class="n">p1</span> <span class="k">INTO</span> <span class="p">(</span><span class="n">PARTITION</span> <span class="n">p0</span> <span class="k">VALUES</span> <span class="k">IN</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">));</span><span class="c1">#将原来的 p0,p1 分区合并起来，放到新的 p0 分区中。
</span></code></pre></div></li>
<li>
<p>HASH/KEY分区重建</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="n">REORGANIZE</span> <span class="n">PARTITION</span> <span class="n">COALESCE</span> <span class="n">PARTITION</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">#用 REORGANIZE 方式重建分区的数量变成2，在这里数量只能减少不能增加。想要增加可以用 ADD PARTITION 方法。
</span></code></pre></div></li>
</ul>
<p><strong>新增分区</strong></p>
<ul>
<li>
<p>新增RANGE分区</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">#新增一个RANGE分区
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">category</span> <span class="k">ADD</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">PARTITION</span> <span class="n">p4</span> <span class="k">VALUES</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">)</span>
            <span class="n">DATA</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data8/data&#39;</span>
            <span class="k">INDEX</span> <span class="n">DIRECTORY</span> <span class="o">=</span> <span class="s1">&#39;/data9/idx&#39;</span><span class="p">);</span>
</code></pre></div></li>
<li>
<p>新增HASH/KEY分区</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="k">ADD</span> <span class="n">PARTITION</span> <span class="n">PARTITIONS</span> <span class="mi">8</span><span class="p">;</span>   <span class="c1">#将分区总数扩展到8个。
</span></code></pre></div></li>
<li>
<p>给已有的表加上分区</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">alter</span> <span class="k">table</span> <span class="n">results</span> <span class="n">partition</span> <span class="k">by</span> <span class="nf">RANGE</span> <span class="p">(</span><span class="nf">month</span><span class="p">(</span><span class="n">ttime</span><span class="p">))</span> 
<span class="p">(</span><span class="n">PARTITION</span> <span class="n">p0</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p1</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">,</span> 
 <span class="n">PARTITION</span> <span class="n">p2</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p3</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">,</span> 
 <span class="n">PARTITION</span> <span class="n">p4</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p5</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="p">,</span> 
 <span class="n">PARTITION</span> <span class="n">p6</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p7</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="p">,</span> 
 <span class="n">PARTITION</span> <span class="n">p8</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">,</span> <span class="n">PARTITION</span> <span class="n">p9</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">,</span>
 <span class="n">PARTITION</span> <span class="n">p10</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">11</span><span class="p">),</span> <span class="n">PARTITION</span> <span class="n">p11</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">12</span><span class="p">),</span>
 <span class="n">PARTITION</span> <span class="n">P12</span> <span class="k">VALUES</span> <span class="n">LESS</span> <span class="nf">THAN</span> <span class="p">(</span><span class="mi">13</span><span class="p">));</span>
</code></pre></div></li>
</ul>
<p><em><strong>默认分区限制分区字段必须是主键（PRIMARY KEY）的一部分，为了除去此限制：</strong></em></p>
<ul>
<li>
<p>方法一</p>
<p>使用ID：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span><span class="o">&gt;</span> <span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">np_pk</span>
    <span class="o">-&gt;</span>     <span class="n">PARTITION</span> <span class="k">BY</span> <span class="nf">HASH</span><span class="p">(</span> <span class="nf">TO_DAYS</span><span class="p">(</span><span class="n">added</span><span class="p">)</span> <span class="p">)</span>
    <span class="o">-&gt;</span>     <span class="n">PARTITIONS</span> <span class="mi">4</span><span class="p">;</span>
<span class="c1">#ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the table&#39;s partitioning function
</span><span class="c1"></span>  
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">np_pk</span>
    <span class="o">-&gt;</span>     <span class="n">PARTITION</span> <span class="k">BY</span> <span class="nf">HASH</span><span class="p">(</span><span class="n">id</span><span class="p">)</span>
    <span class="o">-&gt;</span>     <span class="n">PARTITIONS</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">Query</span> <span class="n">OK</span><span class="p">,</span> <span class="mi">0</span> <span class="n">rows</span> <span class="nf">affected</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">11</span> <span class="n">sec</span><span class="p">)</span>
<span class="n">Records</span><span class="p">:</span> <span class="mi">0</span> <span class="n">Duplicates</span><span class="p">:</span> <span class="mi">0</span> <span class="n">Warnings</span><span class="p">:</span> <span class="mi">0</span>
</code></pre></div></li>
<li>
<p>方法二</p>
<p>将原有pk去掉生成新的pk：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">alter</span> <span class="k">table</span> <span class="n">results</span> <span class="k">drop</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">;</span>
<span class="k">alter</span> <span class="k">table</span> <span class="n">results</span> <span class="k">add</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">ttime</span><span class="p">);</span>
</code></pre></div></li>
</ul>
<h3 id="分区维护">分区维护</h3>
<p>对于分区表，MySQL不支持命令CHECK TABLE，OPTIMIZE TABLE，ANALYZE TABLE，或REPAIR TABLE。作为替代，可以使用ALTER TABLE 的许多扩展来在一个或多个分区上直接地执行这些操作，如下面列出的那样：</p>
<p><strong>重建分区</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="n">REBUILD</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span><span class="err">；</span>
</code></pre></div><p>优化分区：如果从分区中删除了大量的行，或者对一个带有可变长度的行（也就是说，有VARCHAR，BLOB，或TEXT类型的列）作了许多修改，可以使用“ALTER TABLE &hellip; OPTIMIZE PARTITION”来收回没有使用的空间，并整理分区数据文件的碎片</p>
<p><strong>优化分区</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">#在一个给定的分区表上使用“OPTIMIZE PARTITION”等同于在那个分区上运行CHECK PARTITION，ANALYZE PARTITION，和REPAIR PARTITION。 
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="k">OPTIMIZE</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span><span class="err">；</span>
</code></pre></div><p><strong>分析分区</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">#读取并保存分区的键分布
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="k">ANALYZE</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">p3</span><span class="p">)</span><span class="err">；</span>
</code></pre></div><p><strong>修补分区</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">#修补被破坏的分区。
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="n">REPAIR</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">p0</span><span class="p">,</span><span class="n">p1</span><span class="p">);</span>
</code></pre></div><p><strong>检查分区</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="c1">#可以使用几乎与对非分区表使用CHECK TABLE 相同的方式检查分区
</span><span class="c1">#这个命令可以告诉你表t1的分区p1中的数据或索引是否已经被破坏。如果发生了这种情况，使用“ALTER TABLE ... REPAIR PARTITION”来修补该分区
</span><span class="c1"></span><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="k">CHECK</span> <span class="nf">PARTITION</span> <span class="p">(</span><span class="n">p1</span><span class="p">)</span><span class="err">；</span>
<span class="c1">#还可以使用mysqlcheck或myisamchk 应用程序，在对表进行分区时所产生的、单独的MYI文件上进行操作，来完成这些任务。
</span></code></pre></div><h2 id="mysiam支持的并发插入">MYSIAM支持的并发插入</h2>
<p>在一定条件下，MYSIAM表也支持查询和插入操作的并发进行</p>
<p>MYSIAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值可以为0、1、2</p>
<ul>
<li>0：不允许并发插入</li>
<li>1：如果mysiam表中没有空洞（即表的中间没有被删除的行），mysiam允许在一个进程读表的同时，另一个进程从表尾插入记录，这也是mysiam的默认设置，如果有空洞的话虽然不能很好地并发，但是mysql还是可以使用insert delayed来提升插入性能（仅适用于mysiam、memory、archive引擎）</li>
<li>2：无论mysiam表中是否有空洞，都允许在表尾并发插入记录，这时MySQL允许insert和select语句在中间没有空数据块的mysiam表中并行运行</li>
</ul>
<h2 id="mysql-innodb行记录模式row_format">MySQL InnoDB行记录模式（ROW_FORMAT）</h2>
<p>行模式主要分为<code>compressed</code>、<code>dynamic</code>、<code>Compact</code>、<code>Redundant</code>等，区别主要体现在硬件层面的存储方式，具体请查阅网络资料（参考：https://www.cnblogs.com/wilburxu/p/9435818.html）</p>
<h2 id="引擎">引擎</h2>
<h3 id="memory引擎">MEMORY引擎</h3>
<p>内存表，一般用于存放临时数据，关闭数据库服务之后数据全部丢失</p>
<p>可通过ma_heap_table_size（默认16MB）控制Memory表的大小</p>
<h2 id="函数">函数</h2>
<h3 id="group_concat">group_concat()</h3>
<p><strong>语法：</strong></p>
<p>group_concat([DISTINCT] 要连接的字段 [Order BY 排序字段 ASC/DESC] [Spearator &lsquo;分隔符&rsquo;])</p>
<p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210313113431061.png" alt="image-20210313113431061"></p>
<p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210313113523239.png" alt="image-20210313113523239"></p>
<p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210313113537599.png" alt="image-20210313113537599"></p>
<p><strong>案例：</strong></p>
<p><code>group_concat()</code>和<code>substring_index()</code>函数连用可解决 group by 后 order by 失效问题（还有一种替代方案是使用<code>max()</code>函数配合 group by 实现与 group by 后 order by 同样的效果），参考：<a href="https://github.com/pippichi/work/tree/master/zk/%E9%80%9A%E7%94%A8%E4%BC%98%E5%8C%96%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/base/supcon-parent">钱依峰<code>app-service</code>项目</a></p>
<h4 id="参数设置与限制说明">参数设置与限制说明</h4>
<p><strong>查看服务器中的设置</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">show</span> <span class="n">variables</span> <span class="k">like</span> <span class="s1">&#39;%group_concat%&#39;</span><span class="p">;</span>
</code></pre></div><p>结果：</p>
<p><img src="/mysql%E8%A1%A5%E5%85%85.assets/image-20210313113735564.png" alt="image-20210313113735564"></p>
<p>以上设置说明当前是默认长度1kb</p>
<p><strong>改变参数值</strong></p>
<p>法一：修改配置文件中参数，新增group_concat_max_len = 10240</p>
<p>法二：在会话中实现，全局或当前session中：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="kt">SET</span> <span class="n">GLOBAL</span> <span class="n">group_concat_max_len</span> <span class="o">=</span> <span class="mi">10240</span><span class="p">;</span>
<span class="kt">SET</span> <span class="n">SESSION</span> <span class="n">group_concat_max_len</span> <span class="o">=</span> <span class="mi">10240</span><span class="p">;</span>
</code></pre></div><h3 id="default">DEFAULT()</h3>
<p>DEFAULT()函数返回表列的默认值</p>
<p>列的DEFAULT值实在没有用户指定的情况下使用的值</p>
<p>为了使用该函数，应该为该列分配一个DEFAULT值，否则会产生错误</p>
<p>用法：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="k">DEFAULT</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">tbl_name</span><span class="p">;</span>
</code></pre></div><h3 id="last_insert_id">LAST_INSERT_ID()</h3>
<p>LAST_INSERT_ID()、LAST_INSERT_ID(<em>expr</em>)</p>
<p>自动返回最后一个INSERT或 UPDATE 问询为 AUTO_INCREMENT列设置的第一个 发生的值。</p>
<pre><code>mysql&gt; SELECT LAST_INSERT_ID();
     -&gt; 195
</code></pre><p>产生的ID 每次连接后保存在服务器中。这意味着函数向一个给定客户端返回的值是该客户端产生对影响AUTO_INCREMENT列的最新语句第一个 AUTO_INCREMENT值的。这个值不能被其它客户端影响，即使它们产生它们自己的AUTO_INCREMENT值。这个行为保证了你能够找回自己的 ID 而不用担心其它客户端的活动，而且不需要加锁或处理。（因为last_insert_id是针对connection的）</p>
<p>假如你使用一个非“magic”值来更新某一行的AUTO_INCREMENT 列，则LAST_INSERT_ID() 的值不会变化(换言之, 一个不是 NULL也不是 0的值)。</p>
<p><strong>重点</strong>: 假如你使用单INSERT语句插入多个行， LAST_INSERT_ID() <em>只</em>返回插入的<em>第一</em>行产生的值。其原因是这使依靠其它服务器复制同样的 INSERT语句变得简单。</p>
<p>例如：</p>
<pre><code>mysql&gt; USE test;
Database changed
mysql&gt; CREATE TABLE t (
    -&gt;   id INT AUTO_INCREMENT NOT NULL PRIMARY KEY,
    -&gt;   name VARCHAR(10) NOT NULL
    -&gt; );

mysql&gt; INSERT INTO t VALUES (NULL, 'Bob');

mysql&gt; SELECT * FROM t;
+----+------+| id | name |
+----+------+|  1 | Bob  |

mysql&gt; SELECT LAST_INSERT_ID();
     -&gt; 1;
mysql&gt; INSERT INTO t VALUES  (NULL, 'Mary'), (NULL, 'Jane'), (NULL, 'Lisa');
mysql&gt; SELECT * FROM t;
+----+------+
| id | name |
|  1 | Bob  |
|  2 | Mary |
|  3 | Jane |
|  4 | Lisa |
+----+------+
mysql&gt; SELECT LAST_INSERT_ID();
    -&gt;2;
</code></pre><p>虽然第二个问询将3 个新行插入 t, 对这些行的第一行产生的 ID 为 2, 这也是 LAST_INSERT_ID()返回的值。</p>
<p>假如你使用 INSERT IGNORE而记录被忽略，则AUTO_INCREMENT 计数器不会增量，而 LAST_INSERT_ID() 返回0, 这反映出没有插入任何记录。</p>
<p><strong>常用用法</strong></p>
<p>若给出作为到LAST_INSERT_ID()的参数<em>expr</em> ，则参数的值被函数返回，并作为被LAST_INSERT_ID()返回的下一个值而被记忆。这可用于模拟序列：</p>
<pre><code>创建一个表，用来控制顺序计数器并使其初始化：
mysql&gt; CREATE TABLE sequence (id INT NOT NULL);
mysql&gt; INSERT INTO sequence VALUES (0);
</code></pre><p>使用该表产生这样的序列数 ：</p>
<pre><code>mysql&gt; UPDATE sequence SET id=LAST_INSERT_ID(id+1);
mysql&gt; SELECT LAST_INSERT_ID();
    -&gt;1;
</code></pre><p>UPDATE 语句会增加顺序计数器并引发向LAST_INSERT_ID() 的下一次调用，用来返回升级后的值。 SELECT 语句会检索这个值。 mysql_insert_id()、C API函数也可用于获取这个值。</p>
<p>你可以不用调用LAST_INSERT_ID()而产生序列，但这样使用这个函数的效用在于 ID值被保存在服务器中，作为自动产生的值。它适用于多个用户，原因是多个用户均可使用 UPDATE语句并用SELECT语句(或mysql_insert_id()),得到他们自己的序列值，而不会影响其它产生他们自己的序列值的客户端或被其它产生他们自己的序列值的客户端所影响。</p>
<p>注意： mysql_insert_id() 仅会在INSERT 和UPDATE语句后面被升级， 因此你不能在执行了其它诸如SELECT或 SET 这样的SQL语句后使用 C API 函数来找回 LAST_INSERT_ID(<em>expr</em>) 对应的值。</p>
<h3 id="row_number和rank和dense_rank">ROW_NUMBER()和RANK()和DENSE_RANK()</h3>
<p>参考：https://developer.aliyun.com/article/593698（mysql8.0窗口函数：rank，dense_rank，row_number 使用上的区别）、https://blog.csdn.net/weixin_40869022/article/details/120275001（ROW_NUMBER和RANK和DENSE_RANK的区别）</p>
<h3 id="substring_index">SUBSTRING_INDEX()</h3>
<p>参考：https://blog.csdn.net/weixin_50853979/article/details/124669207</p>
<h3 id="cast">CAST()</h3>
<p>参考：https://blog.csdn.net/Hudas/article/details/124399908</p>
<h3 id="timestampdiff">TIMESTAMPDIFF()</h3>
<p>时间差函数</p>
<p>语法：<code>TIMESTAMPDIFF(unit, begin, end)</code></p>
<p>参考：https://blog.csdn.net/qq_16470351/article/details/103686956</p>
<h2 id="属性">属性</h2>
<h3 id="identity">@@identity</h3>
<p>跟函数<code>last_insert_id()</code>的返回值一样，@@identity表示的是最近一次向具有identity属性(即自增列)的表插入数据时对应的自增列的值,是系统定义的全局变量。</p>
<h3 id="names">NAMES</h3>
<p>MySQL中<code>SET NAMES charset_name</code> 相当于设置了3个session变量：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="kt">SET</span> <span class="n">character_set_client</span> <span class="o">=</span> <span class="n">charset_name</span><span class="p">;</span>
<span class="kt">SET</span> <span class="n">character_set_results</span> <span class="o">=</span> <span class="n">charset_name</span><span class="p">;</span>
<span class="kt">SET</span> <span class="n">character_set_connection</span> <span class="o">=</span> <span class="n">charset_name</span><span class="p">;</span>
</code></pre></div><p>参考：https://blog.csdn.net/czh500/article/details/86665509（MySQL SET NAMES）</p>
<h3 id="foreign_key_checks"><code>FOREIGN_KEY_CHECKS</code></h3>
<p>禁用外码约束：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="kt">SET</span> <span class="n">FOREIGN_KEY_CHECKS</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</code></pre></div><p>启动外码约束：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="kt">SET</span> <span class="n">FOREIGN_KEY_CHECKS</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>查看当前<code>FOREIGN_KEY_CHECKS</code>的值可用如下命令：</p>
<div class="highlight"><pre class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">SELECT</span> <span class="o">@@</span><span class="n">FOREIGN_KEY_CHECKS</span><span class="p">;</span>
</code></pre></div><h2 id="canal和binlog">Canal和Binlog</h2>
<p>MySQL Binlog 是一种实时的数据流，用于主从节点之间的数据复制，我们可以利用它来进行数据抽取。</p>
<p>Canal 能够非常便捷地将 MySQL 中的数据抽取到任意目标存储中，使用Canal能做很多很灵活的事情，包括不规则表结构的数据迁移等。</p>
<p>参考：https://blog.csdn.net/zjerryj/article/details/77152226（使用 Binlog 和 Canal 从 MySQL 抽取数据）、https://blog.csdn.net/singgel/article/details/86166154（canal实现mysql实时数据binlog同步）、https://blog.csdn.net/qq_36724582/article/details/124267612（Canal使用流程、部署安装文档）</p>
<h2 id="环形多主多从部署">环形多主多从部署</h2>
<p>参考：https://lostphp.com/blog/623.html（关于mysql主从复制（单向、双向、环状））、https://blog.csdn.net/rockyzhuo2014/article/details/82316619（Mysql主从复制、双向同步、环形同步实现）、https://blog.csdn.net/weixin_45742032/article/details/117554233（MYSQL多主多从）</p>
<h2 id="读写分离">读写分离</h2>
<p>参考：https://blog.csdn.net/FateZRK/article/details/125526077（MySQL读写分离）</p>
  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>MySQL补充</b><nav id="TableOfContents">
  <ul>
    <li><a href="#使用yum安装mysql8">使用yum安装MySQL8</a></li>
    <li><a href="#collate">COLLATE</a>
      <ul>
        <li><a href="#collate的作用">COLLATE的作用</a></li>
        <li><a href="#各种collate的区别">各种COLLATE的区别</a></li>
        <li><a href="#使用show-collation查看mysql支持的所有collate">使用SHOW COLLATION查看MySQL支持的所有COLLATE</a></li>
        <li><a href="#collate设置级别及其优先级">COLLATE设置级别及其优先级</a></li>
      </ul>
    </li>
    <li><a href="#check检查表的状况查看表是否损坏">CHECK检查表的状况（查看表是否损坏）</a></li>
    <li><a href="#analyze关键字">ANALYZE关键字</a></li>
    <li><a href="#repair-table修复表">repair table修复表★</a></li>
    <li><a href="#innodb数据损坏修复">InnoDB数据损坏修复</a></li>
    <li><a href="#数据备份">数据备份</a></li>
    <li><a href="#optimize关键字">OPTIMIZE关键字</a></li>
    <li><a href="#duplicate关键字">DUPLICATE关键字</a></li>
    <li><a href="#delayed关键字">DELAYED关键字</a></li>
    <li><a href="#cache-index语句">CACHE INDEX语句</a></li>
    <li><a href="#load-index-into-cache语句">LOAD INDEX INTO CACHE语句</a></li>
    <li><a href="#ignore关键字">IGNORE关键字</a></li>
    <li><a href="#select--for-update使用方法">SELECT &hellip; FOR UPDATE使用方法</a></li>
    <li><a href="#筛选并查看变量">筛选并查看变量</a></li>
    <li><a href="#查看已安装的插件">查看已安装的插件</a></li>
    <li><a href="#generated-column">generated column</a>
      <ul>
        <li><a href="#generated-column上创建索引与oracle的函数索引的区别">Generated Column上创建索引与Oracle的函数索引的区别</a></li>
      </ul>
    </li>
    <li><a href="#binary类型">Binary类型</a></li>
    <li><a href="#unsigned类型">unsigned类型</a></li>
    <li><a href="#zerofill">ZEROFILL</a></li>
    <li><a href="#comment">COMMENT</a></li>
    <li><a href="#replace-into">REPLACE INTO</a></li>
    <li><a href="#内连接外连接">内连接、外连接</a></li>
    <li><a href="#外键约束on-delete和on-update的使用">外键约束（on delete和on update）的使用</a></li>
    <li><a href="#外键约束以及建立索引-create-index">外键约束以及建立索引（ create index）</a></li>
    <li><a href="#mysql的current_timestamp">Mysql的CURRENT_TIMESTAMP</a></li>
    <li><a href="#联合algorithm创建视图">联合algorithm创建视图</a></li>
    <li><a href="#ifnullnullif其他">Ifnull|nullif|其他</a></li>
    <li><a href="#查看mysql网络连接相关的变量属性与网络连接状态">查看MySQL网络连接相关的变量属性与网络连接状态</a></li>
    <li><a href="#索引">索引</a>
      <ul>
        <li><a href="#创建索引">创建索引</a></li>
        <li><a href="#创建表时添加索引">创建表时添加索引</a></li>
        <li><a href="#删除索引">删除索引</a></li>
        <li><a href="#普通索引">普通索引</a></li>
        <li><a href="#唯一索引">唯一索引</a></li>
        <li><a href="#创建表时添加唯一索引">创建表时添加唯一索引</a></li>
        <li><a href="#有四种方式来添加数据表的索引">有四种方式来添加数据表的索引</a></li>
        <li><a href="#回表索引下推">回表、索引下推</a></li>
      </ul>
    </li>
    <li><a href="#全文索引">全文索引</a>
      <ul>
        <li><a href="#版本支持">版本支持</a></li>
        <li><a href="#创建全文索引">创建全文索引</a></li>
        <li><a href="#修改全文索引">修改全文索引</a></li>
        <li><a href="#删除全文索引">删除全文索引</a></li>
        <li><a href="#使用全文索引">使用全文索引</a></li>
        <li><a href="#两种全文索引">两种全文索引</a></li>
        <li><a href="#小结">小结</a></li>
        <li><a href="#全文索引测试示例">全文索引测试示例</a></li>
      </ul>
    </li>
    <li><a href="#空间索引spatial">空间索引spatial</a>
      <ul>
        <li><a href="#geometry类型">geometry类型</a></li>
      </ul>
    </li>
    <li><a href="#索引中的visible与invisible">索引中的visible与invisible</a></li>
    <li><a href="#mysql查询某个表的字段名">mysql查询某个表的字段名</a>
      <ul>
        <li><a href="#描述表字段信息">描述表字段信息</a></li>
        <li><a href="#查表字段及其信息">查表字段及其信息</a></li>
        <li><a href="#information_schema库详解存放mysql的元数据">information_schema库详解（存放MySQL的元数据）</a></li>
      </ul>
    </li>
    <li><a href="#maxvalue关键字">MAXVALUE关键字</a></li>
    <li><a href="#mysql分区partition功能">MySQL分区（partition）功能</a>
      <ul>
        <li><a href="#分区表和未分区表试验过程">分区表和未分区表试验过程</a></li>
        <li><a href="#分区命令详解">分区命令详解</a></li>
        <li><a href="#分区管理">分区管理</a></li>
        <li><a href="#分区维护">分区维护</a></li>
      </ul>
    </li>
    <li><a href="#mysiam支持的并发插入">MYSIAM支持的并发插入</a></li>
    <li><a href="#mysql-innodb行记录模式row_format">MySQL InnoDB行记录模式（ROW_FORMAT）</a></li>
    <li><a href="#引擎">引擎</a>
      <ul>
        <li><a href="#memory引擎">MEMORY引擎</a></li>
      </ul>
    </li>
    <li><a href="#函数">函数</a>
      <ul>
        <li><a href="#group_concat">group_concat()</a></li>
        <li><a href="#default">DEFAULT()</a></li>
        <li><a href="#last_insert_id">LAST_INSERT_ID()</a></li>
        <li><a href="#row_number和rank和dense_rank">ROW_NUMBER()和RANK()和DENSE_RANK()</a></li>
        <li><a href="#substring_index">SUBSTRING_INDEX()</a></li>
        <li><a href="#cast">CAST()</a></li>
        <li><a href="#timestampdiff">TIMESTAMPDIFF()</a></li>
      </ul>
    </li>
    <li><a href="#属性">属性</a>
      <ul>
        <li><a href="#identity">@@identity</a></li>
        <li><a href="#names">NAMES</a></li>
        <li><a href="#foreign_key_checks"><code>FOREIGN_KEY_CHECKS</code></a></li>
      </ul>
    </li>
    <li><a href="#canal和binlog">Canal和Binlog</a></li>
    <li><a href="#环形多主多从部署">环形多主多从部署</a></li>
    <li><a href="#读写分离">读写分离</a></li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    ©QYF Just for record 2018-2021 &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
