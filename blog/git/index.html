<!DOCTYPE html>
<html>
  <head>
    
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-12345678-0', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

    
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>
      
  Git &ndash; Learning Records

    </title>
    
    <meta content="Git" name="keywords">
    
    
    <meta name="description" property="og:description" content="The article contains the knowledge of Git&amp;hellip;
|Just for record">
    

    <meta name="apple-mobile-web-app-title" content="Learning Records">
    
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@">
    <meta name="twitter:title" content="Git | Learning Records">
    <meta name="twitter:description" content="The article contains the knowledge of Git&hellip;|Just for record">
    <meta name="twitter:image" content="https://pippichi.github.iotwitter-card.png">
    


    <link rel="stylesheet" href="/assets/syntax.css">
    <link rel="stylesheet" href="/assets/primer-build.css">
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="stylesheet" href="/assets/custom_style.css">
  </head>


  <body class="bg-gray">
    <div id="holy" class="container-lg bg-white h-100">

      <div id="header" class="px-1 bg-white">
        <nav class="UnderlineNav UnderlineNav--right px-2">
  <a class="UnderlineNav-actions muted-link h2" href="https://pippichi.github.io">
    Learning Records
  </a>

  
  
  <div class="UnderlineNav-body">
    
    
    
    <a class="UnderlineNav-item" href="/blog/">
      
      <span>Home</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item" href="/">
      
      <span>PDF/CODE</span>
    </a>
    
    
    
    
    <a class="UnderlineNav-item" href="/about/">
      
      <span>About</span>
    </a>
    
    
  </div>
  
</nav>

      </div>

      <div role="main" id="main" class="holy-main markdown-body px-4 bg-white">
        

<div class="Subhead">
  <div class="Subhead-heading">
    <div class="h1 mt-3 mb-1">Git</div>
  </div>
  <div class="Subhead-description">
    


<a href='/categories/basic' class="muted-link">
  <span class="Label Label--gray-darker">Basic</span>
</a>



<a href='/tags/git' class="muted-link">
  <span class="Label Label--gray">Git</span>
</a>



    
    <div class="float-md-right">
      <span title="Lastmod: 2019-07-01. Published at: 2019-07-01.">
        
          Published: 2019-07-01
        
      </span>
    </div>
    
  </div>
</div>
<article>
  
  <section class="pb-6 mb-3 border-bottom">
    <p>The article contains the knowledge of Git&hellip;</p>
<h2 id="生成密钥">生成密钥</h2>
<p>ssh-keygen -t rsa -C “email”</p>
<p>.ssh文件下的config 用于配置账号</p>
<p><img src="/git/4e8c7a80a72d698019b06dfb23078a3c.png" alt=""></p>
<h2 id="git上传大文件">git上传大文件</h2>
<p>有时候git上传文件会报错：<code>remote: fatal: pack exceeds maximum allowed size</code></p>
<p>这是因为上传的文件的大小超出了限制</p>
<p>可以使用<code>git-lfs</code>插件解决这个问题，参考：https://cloud.tencent.com/developer/article/1785066</p>
<h2 id="git-config"><strong>git config</strong></h2>
<p><strong>配置git提交的用户名和邮件：</strong><br>
格式：git config <a href="http://user.name/">user.name</a> 用户名；git config user.email
邮箱</p>
<h3 id="查看当前的用户名和邮箱">查看当前的用户名和邮箱</h3>
<pre><code>$ git config user.name
$ git config user.email
</code></pre><h3 id="修改git的用户名和邮箱">修改git的用户名和邮箱</h3>
<p><img src="/git/893ebb45a22726cae25133d1adc607bb.png" alt=""></p>
<h2 id="git-add">git add</h2>
<p>Git add xxx/Git add .</p>
<h2 id="gitgnore失效问题">.gitgnore失效问题</h2>
<p>有时候我们在.gitgnore编写了规则，但却不起作用，那很可能是这种情况：使用IDEA的时候开启了自动接受git管理的功能，导致新增的文件自动被add进git本地工作栈，导致该文件被git管理，这个时候就算在.gitgnore添加了该文件的排除规则也不会起作用，原因就是它已经被git管理了</p>
<p>那么如何解除呢？</p>
<p>使用<code>git rm --cached filename</code>，这样就可以不受git管理了</p>
<p>如果执行了上面这行代码之后还是无法解除，那就只能执行git rm或git rm -f命令将文件从工作区和暂存区删除，一般情况下这么操作之后问题都会得到解决</p>
<h2 id="git-rm">git rm</h2>
<h3 id="rm命令">rm命令</h3>
<p>作用：删除工作区的文件</p>
<p>如果要影响暂存区中文件，需要add和commit</p>
<p>如果要影响版本库中文件，需要add和commit和push</p>
<h3 id="git-rm命令">git rm命令</h3>
<p>作用：删除工作区文件，同时将此次删除放入暂存区</p>
<p>注意：<!-- raw HTML omitted -->要删除的文件是没有修改过的<!-- raw HTML omitted -->，就是说和当前版本库文件的内容相同</p>
<p>如果要影响到暂存区文件，不需要再add了，直接commit即可</p>
<p>如果要影响到版本库文件，不需要再add了，直接commit和push即可</p>
<h3 id="git-rm--f命令">git rm -f命令</h3>
<p>作用：删除工作区和暂存区文件，并将此次删除放入暂存区</p>
<p>注意：<!-- raw HTML omitted -->要删除的文件已经修改过<!-- raw HTML omitted -->，就是说和当前版本库文件的内容不同</p>
<p>如果要影响到暂存区文件，不需要再add了，直接commit即可</p>
<p>如果要影响到版本库文件，不需要再add了，直接commit和push即可</p>
<h3 id="git-rm---cached命令"><code>git rm --cached</code>命令（★）</h3>
<p>作用：删除暂存区文件，但保留工作区的文件，并将此次删除放入暂存区（相当于是取消了git对该文件的跟踪）</p>
<p>如果要影响暂存区中文件，不需要再add了，直接commit即可</p>
<p>如果要影响版本库中文件，不需要再add了，直接commit和push即可（此时版本库中的该文件也会被删除，最终的结果就是只有工作区会保留该文件，而暂存区和版本库中该文件都会被删除）</p>
<h3 id="git-rm--rf---cached-foldname"><code>git rm -rf --cached foldname</code></h3>
<p><code>git rm --cached</code>是删除单个缓存文件，<code>git rm -rf --cached</code>是删除整个缓存目录</p>
<h3 id="git-rm--r---cached-"><code>git rm -r --cached .</code></h3>
<p>如果想要删除的已缓存文件或文件夹比较多或者在使用.gitgnore时想要忽略的文件或文件夹比较多，可以使用该命令重置所有缓存（该命令会移除所有缓存索引），再次提交（add、commit）后将刷新.gitgnore指示的忽略文件</p>
<h2 id="git-restore与git-restore---staged">git restore与<code>git restore --staged</code></h2>
<p><code>git restore</code>指令使得在工作空间但是不在暂存区的文件撤销更改(内容恢复到没修改之前的状态)</p>
<p>举个例子：我修改了<code>a.txt</code>文件，但是还没有将它<code>add</code>到暂存区，此时使用<code>git restore a.txt</code>命令可以将<code>a.txt</code>文件恢复到未修改之前的状态</p>
<p><code>git restore --staged</code>的作用是将暂存区的文件从暂存区撤出，但不会更改文件的内容。</p>
<p>举个例子：我修改了<code>a.txt</code>文件，并且将它<code>add</code>到暂存区，此时使用<code>git restore --staged a.txt</code>命令可以将<code>a.txt</code>文件移出暂存区，并且修改的操作是被保留的（该文件的内容是被修改之后的内容而不是未被修改之前的内容）</p>
<h2 id="查看git当前状态">查看git当前状态</h2>
<p>Git status</p>
<h2 id="git-log">git log</h2>
<p>Git log</p>
<p><img src="/git/f73b7b4f0022f29e15cc6894b6ff4ea9.png" alt=""></p>
<p>git log –pretty=oneline (类似的还有<a href="https://www.jianshu.com/p/0805b5d5d893">https://www.jianshu.com/p/0805b5d5d893</a>)</p>
<p><img src="/git/54e741f712d0b98538e2ced549fc0ebc.png" alt=""></p>
<h2 id="git-reflog用于查看所有版本的回退信息">git reflog用于查看所有版本的回退信息</h2>
<p>Git reflog , 可以查看所有的版本回退信息，相比较之下git log
–oneline就只能显示过去的。</p>
<p><img src="/git/cce0387acf21e6209d47e09088338650.png" alt=""></p>
<h2 id="git-commit">git commit</h2>
<p>Git commit -m xxx</p>
<p>Git commit –amend -m xxx</p>
<p>解决冲突：</p>
<p><img src="/git/157d35890cbf4a5cb5d5d0d5a9b99e1b.png" alt=""></p>
<h2 id="git-tag">git tag</h2>
<h3 id="创建标签">创建标签</h3>
<p>标签分为两种：轻量标签和附注标签</p>
<p>轻量标签很像一个不会改变的分支，它只是某个特定提交的引用。而附注标签是存储在git数据库中的一个完整对象，它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间，此外还有一个标签信息，并且可以使用GNU Privacy Guard（GPG）签名并验证。通常会建议创建附注标签，这样就可以拥有以上所有信息。但如果只是想用一个临时的标签，或者因为某些原因不想保存这些信息，那也可以使用轻量标签。</p>
<h4 id="附注标签">附注标签</h4>
<p>git tag -a v1.4 -m &lsquo;my version 1.4&rsquo; （-a制定标签名字，-m指定一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，git会启动编辑器要求你输入信息）</p>
<p>git tag（打标签）</p>
<p><img src="/git/7b0b7e58e0825ad93c37662fd50ad252.png" alt=""></p>
<h4 id="轻量标签">轻量标签</h4>
<p>另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 <code>-a</code>、<code>-s</code> 或 <code>-m</code> 选项，只需要提供标签名字</p>
<p>git tag ”标签名“</p>
<p>这个时候使用git show &ldquo;标签名&quot;查找该轻量标签，我们将不会看到额外的标签信息，只会显示出提交信息</p>
<h3 id="查看标签信息和与之对应的提交信息">查看标签信息和与之对应的提交信息</h3>
<p>git show 显示所有标签</p>
<p>git show “标签名&rdquo; 显示某个标签</p>
<p>输出会显示打标签者的信息、打标签的日期时间、附注信息以及具体的提交信息</p>
<p><img src="/git/3a390a01504a299a448ae0aaa1467d0d.png" alt=""></p>
<p>标签测试:</p>
<p><img src="/git/164303cfad12a2488f01077cb6542734.png" alt=""></p>
<p>完成文件修改之后，git tag -a xxx1 -m xxx2,设置标签名xxx1</p>
<p>将某一个标签推上去Git push origin xxx(标签名)</p>
<p>将所有标签推上去 git push origin –tags</p>
<h3 id="列出标签">列出标签</h3>
<p>git tag</p>
<h3 id="模糊查找特定标签">模糊查找特定标签</h3>
<p>git tag -l &ldquo;v18.5*&rdquo;</p>
<p>那就会列出所有v18.5开头的标签，比如v18.5.1、v18.5等</p>
<h3 id="后期打标签">后期打标签</h3>
<p>当提交了多次代码之后我们希望给其中的某几次提交的代码打上标签</p>
<p>此时可以使用命令：<code>git log --pretty=oneline</code> 显示提交信息，如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">$</span> <span class="n">git</span> <span class="n">log</span> <span class="o">--</span><span class="n">pretty</span><span class="o">=</span><span class="n">oneline</span>
<span class="n">15027957951b64cf874c3557a0f3547bd83b3ff6</span> <span class="n">Merge</span> <span class="n">branch</span> <span class="err">&#39;</span><span class="n">experiment</span><span class="err">&#39;</span>
<span class="n">a6b4c97498bd301d84096da251c98a07c7723e65</span> <span class="n">beginning</span> <span class="n">write</span> <span class="n">support</span>
<span class="n">0d52aaab4479697da7686c15f77a3d64d9165190</span> <span class="n">one</span> <span class="n">more</span> <span class="n">thing</span>
</code></pre></div><p>再使用命令给某次提交打标签：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">$</span> <span class="n">git</span> <span class="n">tag</span> <span class="o">-</span><span class="n">a</span> <span class="n">v1</span><span class="o">.</span><span class="na">2</span> <span class="n">0d52aaa</span>
</code></pre></div><h3 id="删除标签">删除标签</h3>
<p>删除本地仓库标签：git tag -d &ldquo;标签名&rdquo;</p>
<p>删除远程仓库的标签，有两种方法：</p>
<ul>
<li>
<p>git push origin :refs/tags/&ldquo;标签名&rdquo;</p>
<p>这种操作的意义是，将冒号前面的空值推送到远程标签名，从而高效地删除它</p>
</li>
<li>
<p>git push origin &ndash;delete &ldquo;标签名&rdquo;</p>
</li>
</ul>
<h3 id="检出标签">检出标签</h3>
<p>如果你想查看某个标签所指向的文件版本，可以使用 <code>git checkout</code> 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用:</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="s">&#34;标签名&#34;</span>
</code></pre></div><p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：</p>
<div class="highlight"><pre class="chroma"><code class="language-java" data-lang="java"><span class="n">$</span> <span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="s">&#34;新标签名&#34;</span> <span class="s">&#34;分支名&#34;</span>
<span class="n">举个例子</span><span class="err">：</span><span class="n">git</span> <span class="n">checkout</span> <span class="o">-</span><span class="n">b</span> <span class="n">version2</span> <span class="n">v2</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">0</span> <span class="n">意思是切到新分支version2上面并指向标签v2</span><span class="o">.</span><span class="na">0</span><span class="o">.</span><span class="na">0的文件版本</span>
</code></pre></div><p>如果在这之后又进行了一次提交，<code>version2</code> 分支就会因为这个改动向前移动， 此时它就会和 <code>v2.0.0</code> 标签稍微有些不同，这时就要当心了。</p>
<h2 id="git回滚">git回滚</h2>
<h3 id="git-revert">git revert</h3>
<p>在git log查询到commit_id之后，使用git revert
commit_id，之后再推送到远端即可回滚。</p>
<p>注意：如果在使用了一次revert之后再使用一次revert就又回去了，这是跟git reset不一样的地方（git reset会使之前的记录全部消失，回滚之后就不能再回去了，所以平时应该避免使用reset，多多使用revert）</p>
<p>git revert一般是这么用的：</p>
<pre><code> * git revert HEAD                  撤销前一次 commit
 * git revert HEAD^                 撤销前前一次 commit
 * git revert commitId              撤销指定的版本，撤销也会作为一次提交进行保存
 * git revert --no-commit commitId  撤销指定的版本，撤销不会作为一次提交进行保存
</code></pre><p>git revert是提交一个新的版本，将需要revert的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容。换句话说，比方说有版本1、版本2、版本3，最新的就是版本3（该版本已经提交了commit），那么如果要回滚到版本2，版本3的commit不会被影响，将文件内容撤销到版本2的操作将会被视为新的修改，如果此时再commit，那么提交的是一个新的版本</p>
<p>git revert还可以带<code>-n</code>等参数，具体参考：https://www.git-scm.com/docs/git-revert</p>
<p>例子：</p>
<p>假设我们执行git log能看到如下信息：</p>
<p><img src="/git/image-20211102225009648.png" alt="image-20211102225009648"></p>
<p>此时如果需要回退到44444版本，就需要revert 555555555 版本</p>
<h3 id="git-reset">git reset</h3>
<p>作用：当我们add和commit之后发现还需要修改代码或者说这次commit是错误的（对于已有文件的改动那问题也不大，但是有种情况就是本地代码库中git托管了某些新建的文件，有时候可能是大量的新建文件，这个时候想要通过git rm恢复到之前这些文件不被托管的状态是很麻烦的），这个时候如果再次commit也是可以的，只不过那些我们本不希望被托管的文件还是会被git托管，并且这样会多一次commit记录（git push之后使用git log可以看到多次commit记录），一般情况下再次commit的话上一次的commit理论上是无意义的。所以综合来看最理想的做法就是取消上一次的commit（本质上就是取消本地代码库中上一次add和commit造成的git对于代码的管理），这个时候git reset就能派上用场了，它不仅能完全取消上一次的commit（相当于没有上一次commit），还能保留工作区的所有未被git管理的代码。</p>
<p>选择当前指针指向的位置 git reset --hard HEAD</p>
<p>回退到上一个版本 <code>git reset --hard HEAD^</code></p>
<p>回退到上两个版本 <code>git reset --hard HEAD^^</code></p>
<p>回退到上三个版本 <code>git reset --hard HEAD^^^</code></p>
<p>回退到某一个确定的版本 <code>git reset --hard xxx</code>(用git log 获得的commit后面的遗传信息码)</p>
<p>回退到上100个版本 <code>git reset --hard HEAD~100</code></p>
<p><strong><code>git reset --hard</code>与<code>git reset --soft</code>的区别：</strong></p>
<p><code>git reset --hard</code>不仅会回退commit，还会将文件也恢复到未修改之前的状态，也就是说他是彻底的回退到了某个版本；而<code>git reset --soft</code>不会将文件恢复到未修改之前的状态，他只会回退commit，如果还要提交，直接commit即可</p>
<p>具体参考：https://blog.csdn.net/yangfengjueqi/article/details/61668381</p>
<h3 id="git-revert与git-reset的区别">git revert与git reset的区别</h3>
<ul>
<li>git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit</li>
<li>在回滚这一操作上看，效果差不多，但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是直接把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入</li>
<li>git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够相互抵消</li>
</ul>
<h2 id="git-branch">git branch</h2>
<p>查看本地及远程所有的分支 git branch -a</p>
<p><img src="/git/3d951c2020409e15562cfbf9f3802df9.png" alt=""></p>
<p>新建分支： <code>git branch branch1</code></p>
<p>创建并切换到新分支：<code>git checkout -b newBranch</code></p>
<p>创建并切换到新分支，且新分支的代码指向某个标签版本：<code>git checkout -b newBranch v1.15.1</code></p>
<p>将branch1推到远程： <code>git checkout branch1</code>,切换到branch1，然后做想要的操作，最后push，遇到操作不对的时候系统会有提示，比方说（最后push的时候其实是<code>git push –set-upstream origin branch1</code>）</p>
<p>案例：</p>
<pre><code>1、在目录下使用git clone git@github.com:xxxxx/yyyyy.git
2、使用git branch查看本地的当前分支
	你会看到你在master分支下
3、这个时候往往会用git checkout -b dev origin/dev这个命令
	它意思是说.切换到dev分支上,接着跟远程的origin地址上的dev分支关联起来,这里要注意origin代表是一个路径,可以用git remote -v 查看。说来白了,origin/dev有点像是git@github.com:xxxxx/yyyyy.git/dev
4、接着在dev当前分支下进行操作,add,commit后,用git push origin dev,意思是推送当前的dev分支到远程origin地址的dev分支上
</code></pre><h3 id="设置分支推送的目的地">设置分支推送的目的地</h3>
<p>默认将本地的<code>dev</code>分支推送到<code>origin/dev</code>：</p>
<pre><code>git branch --set-upstream-to=origin/dev dev
git branch --set-upstream dev origin/dev
</code></pre><p>当然也可以在<code>pull</code>或<code>push</code>的时候去设置，比方说我们熟悉的：<code>git push –set-upstream origin branch1</code></p>
<h3 id="设置推送方式">设置推送方式</h3>
<pre><code>git config --global push.default xxx
</code></pre><p>上面的<code>xxx</code>可以是：<code>nothing</code>、<code>matching</code>、<code>upstream</code>、<code>simple</code>、<code>current</code>。对于这些模式的解释（来自官网）：</p>
<pre><code>push.default

Defines the action git push should take if no refspec is given on the command line, no refspec is configured in the remote, and no refspec is implied by any of the options given on the command line. Possible values are:

		nothing – do not push anything.
		
		matching – push all branches having the same name in both ends. This is for those who prepare all the branches into a publishable shape and then push them out with a single command. It is not appropriate for pushing into a repository shared by multiple users, since locally stalled branches will attempt a non-fast forward push if other users updated the branch.
This is currently the default, but Git 2.0 will change the default to simple.

		upstream – push the current branch to its upstream branch. With this, git push will update the same remote ref as the one which is merged by git pull, making push and pull symmetrical. See “branch.&lt;name&gt;.merge” for how to configure the upstream branch.
		
		simple – like upstream, but refuses to push if the upstream branch’s name is different from the local one. This is the safest option and is well-suited for beginners. It will become the default in Git 2.0.
		
		current – push the current branch to a branch of the same name.
		
		
The simple, current and upstream modes are for those who want to push out a single branch after finishing work, even when the other branches are not yet ready to be pushed out. If you are working with other people to push into the same shared repository, you would want to use one of these.
</code></pre><p>大体是说simple是最安全的，也非常适合初学者。simple也将是Git2.0的默认值</p>
<h3 id="删除分支">删除分支</h3>
<p>把本地的分支删除 <code>git branch -d xxx</code>，之后要是想将远程的分支也删除 <code>git push origin --delete :xxx</code>或<code>git push origin :xxx</code></p>
<h3 id="查看本地分支">查看本地分支</h3>
<p>git branch</p>
<h3 id="查看全部分支包含本地的和远程的">查看全部分支（包含本地的和远程的）</h3>
<p>git branch -a</p>
<h3 id="如果分支太多可以配合grep模糊查找">如果分支太多，可以配合grep模糊查找</h3>
<p>git branch | grep &ldquo;branchName&rdquo;</p>
<h3 id="清理本地无效分支远程已经删除但是本地没有删除的分支">清理本地无效分支（远程已经删除但是本地没有删除的分支）</h3>
<p>git fetch -p</p>
<h3 id="根据指定版本号创建分支">根据指定版本号创建分支</h3>
<p>git checkout -b branchName commitId</p>
<h2 id="git-switch">git switch</h2>
<p>相较于功能较多的git checkout，git switch专门用于切换分支</p>
<p>参考：https://blog.csdn.net/zxlyx/article/details/124218646（git switch 命令的一些常用的用法）</p>
<h2 id="git-merge">git merge</h2>
<p>合并分支 先将分支切换到master：git checkout master，然后git merge branch1即可</p>
<h2 id="fork">fork</h2>
<p>Fork：将别人的仓库复制一份到自己的仓库</p>
<h2 id="clone">clone</h2>
<p>Clone：将仓库克隆到自己的本地电脑中</p>
<p><img src="/git/9ff4a2b11aad45e2c6631b0a1edd243d.png" alt=""></p>
<h2 id="fetchmergepull">fetch、merge、pull</h2>
<p>fetch+merge的效果与pull一样</p>
<h3 id="git-pull和git-pull---rebase的区别">git pull和git pull &ndash;rebase的区别</h3>
<p>rebase好处</p>
<p>想要更好的提交树，使用rebase操作会更好一点。<br>
这样可以线性的看到每一次提交，并且没有增加提交节点。</p>
<p>merge 操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add
修改，commit 就可以了。</p>
<p>而rebase 操作的话，会中断rebase,同时会提示去解决冲突。<br>
解决冲突后,将修改add后执行git rebase –continue继续操作，或者git rebase
–skip忽略冲突。</p>
<h2 id="git-remote">git remote</h2>
<p>Git添加远程仓库：</p>
<p><code>git remote add origin git@github.com:michaelliao/learngit.git</code></p>
<p>Git删除远程仓库：</p>
<p><code>git remote rm origin</code></p>
<p>Git重定向远程仓库地址：</p>
<p><code>git remote set-url origin xxxxx</code></p>
<p>Git重命名origin：</p>
<p><code>git remote rename origin xxxxx</code></p>
<p>查看远程仓库当前路径：</p>
<p><code>git remote</code></p>
<p><img src="/git/image-20220105232710554.png" alt="image-20220105232710554"></p>
<p>这里origin代表的其实是一个路径</p>
<p>查看远程仓库中origin路径（origin代表的是一个路径）：</p>
<p><code>git remote -v</code></p>
<p><img src="/git/image-20220105232808836.png" alt="image-20220105232808836"></p>
<h2 id="git-stash">git stash</h2>
<p>git stash #可用来暂存当前正在进行的工作<br>
git stash pop #从Git栈中读取最近一次保存的内容</p>
<h2 id="git-diff">git diff</h2>
<p><code>git diff</code>用来比较文件之间的不同</p>
<p>具体用法参考：</p>
<p><a href="https://blog.csdn.net/wq6ylg08/article/details/88798254">https://blog.csdn.net/wq6ylg08/article/details/88798254</a></p>
<p><a href="https://git-scm.com/docs/git-diff">https://git-scm.com/docs/git-diff</a></p>
<h2 id="git-remote-prune-origin">git remote prune origin</h2>
<p>有些分支在远程已经被删掉了，但在本地还未被删除，该命令就是用于清除本地的这些分支的。</p>
<p>参考：https://www.cnblogs.com/wangiqngpei557/p/6058115.html（聊下 git remote prune origin）</p>
<h2 id="git对于提交记录的修改git-rebasegit-commit---amendpick命令drop命令git-filter-branch--f---commit-filtergit-filter-branch---tree-filter等">git对于提交记录的修改（<code>git rebase</code>、<code>git commit --amend</code>、pick命令、drop命令、<code>git filter-branch -f --commit-filter</code>、<code>git filter-branch --tree-filter</code>等）</h2>
<p>参考：https://blog.csdn.net/LeoForBest/article/details/90313471（Git 删除提交\commit的log记录、修改历史提交消息、删除历史提交、修改所有提交的邮箱地址、从所有提交中删除一个文件）</p>
<h2 id="一台windows上管理多个公匙">一台windows上管理多个公匙</h2>
<p><img src="/git/307d527d75cecc8d516028a7715fa448.png" alt=""></p>
<p><img src="/git/2cb1825f9870519a7b999d927927033b.png" alt=""></p>
<p><img src="/git/4d52ccc7760805b195ba86b7498fca79.png" alt=""></p>
<p><img src="/git/f958aea23314ddddd6dcf9cf5ed9e32d.png" alt=""></p>
<p><img src="/git/03526abc68afa6893cd239e29178a219.png" alt=""></p>
<p><img src="/git/f9e94113a0e61bb338dfe32335a5eb20.png" alt=""></p>
<h2 id="更多">更多</h2>
<p>更多详细命令：<a href="https://blog.csdn.net/weixin_30699831/article/details/101982286">https://blog.csdn.net/weixin_30699831/article/details/101982286</a></p>
<p><a href="https://www.jianshu.com/p/d641df66fd28">https://www.jianshu.com/p/d641df66fd28</a></p>
<p><img src="/git/a569bd4ffbba6cbd31bfdcb5fe342887.png" alt=""></p>
<p>github网址后面加上compare就能比较各个标签之间的区别</p>
<p>GitHub的搜索技巧：<a href="https://www.cnblogs.com/liweiweicode/p/11918615.html">https://www.cnblogs.com/liweiweicode/p/11918615.html</a></p>
  </section>

  <section>
    
      
    
  </section>
</article>

      </div>

      <div id="side" class="pr-1 bg-white">
        <aside class="pr-3">
          
  
    <div id="toc" class="Box Box--blue mb-3">
      <b>Git</b><nav id="TableOfContents">
  <ul>
    <li><a href="#生成密钥">生成密钥</a></li>
    <li><a href="#git上传大文件">git上传大文件</a></li>
    <li><a href="#git-config"><strong>git config</strong></a>
      <ul>
        <li><a href="#查看当前的用户名和邮箱">查看当前的用户名和邮箱</a></li>
        <li><a href="#修改git的用户名和邮箱">修改git的用户名和邮箱</a></li>
      </ul>
    </li>
    <li><a href="#git-add">git add</a></li>
    <li><a href="#gitgnore失效问题">.gitgnore失效问题</a></li>
    <li><a href="#git-rm">git rm</a>
      <ul>
        <li><a href="#rm命令">rm命令</a></li>
        <li><a href="#git-rm命令">git rm命令</a></li>
        <li><a href="#git-rm--f命令">git rm -f命令</a></li>
        <li><a href="#git-rm---cached命令"><code>git rm --cached</code>命令（★）</a></li>
        <li><a href="#git-rm--rf---cached-foldname"><code>git rm -rf --cached foldname</code></a></li>
        <li><a href="#git-rm--r---cached-"><code>git rm -r --cached .</code></a></li>
      </ul>
    </li>
    <li><a href="#git-restore与git-restore---staged">git restore与<code>git restore --staged</code></a></li>
    <li><a href="#查看git当前状态">查看git当前状态</a></li>
    <li><a href="#git-log">git log</a></li>
    <li><a href="#git-reflog用于查看所有版本的回退信息">git reflog用于查看所有版本的回退信息</a></li>
    <li><a href="#git-commit">git commit</a></li>
    <li><a href="#git-tag">git tag</a>
      <ul>
        <li><a href="#创建标签">创建标签</a></li>
        <li><a href="#查看标签信息和与之对应的提交信息">查看标签信息和与之对应的提交信息</a></li>
        <li><a href="#列出标签">列出标签</a></li>
        <li><a href="#模糊查找特定标签">模糊查找特定标签</a></li>
        <li><a href="#后期打标签">后期打标签</a></li>
        <li><a href="#删除标签">删除标签</a></li>
        <li><a href="#检出标签">检出标签</a></li>
      </ul>
    </li>
    <li><a href="#git回滚">git回滚</a>
      <ul>
        <li><a href="#git-revert">git revert</a></li>
        <li><a href="#git-reset">git reset</a></li>
        <li><a href="#git-revert与git-reset的区别">git revert与git reset的区别</a></li>
      </ul>
    </li>
    <li><a href="#git-branch">git branch</a>
      <ul>
        <li><a href="#设置分支推送的目的地">设置分支推送的目的地</a></li>
        <li><a href="#设置推送方式">设置推送方式</a></li>
        <li><a href="#删除分支">删除分支</a></li>
        <li><a href="#查看本地分支">查看本地分支</a></li>
        <li><a href="#查看全部分支包含本地的和远程的">查看全部分支（包含本地的和远程的）</a></li>
        <li><a href="#如果分支太多可以配合grep模糊查找">如果分支太多，可以配合grep模糊查找</a></li>
        <li><a href="#清理本地无效分支远程已经删除但是本地没有删除的分支">清理本地无效分支（远程已经删除但是本地没有删除的分支）</a></li>
        <li><a href="#根据指定版本号创建分支">根据指定版本号创建分支</a></li>
      </ul>
    </li>
    <li><a href="#git-switch">git switch</a></li>
    <li><a href="#git-merge">git merge</a></li>
    <li><a href="#fork">fork</a></li>
    <li><a href="#clone">clone</a></li>
    <li><a href="#fetchmergepull">fetch、merge、pull</a>
      <ul>
        <li><a href="#git-pull和git-pull---rebase的区别">git pull和git pull &ndash;rebase的区别</a></li>
      </ul>
    </li>
    <li><a href="#git-remote">git remote</a></li>
    <li><a href="#git-stash">git stash</a></li>
    <li><a href="#git-diff">git diff</a></li>
    <li><a href="#git-remote-prune-origin">git remote prune origin</a></li>
    <li><a href="#git对于提交记录的修改git-rebasegit-commit---amendpick命令drop命令git-filter-branch--f---commit-filtergit-filter-branch---tree-filter等">git对于提交记录的修改（<code>git rebase</code>、<code>git commit --amend</code>、pick命令、drop命令、<code>git filter-branch -f --commit-filter</code>、<code>git filter-branch --tree-filter</code>等）</a></li>
    <li><a href="#一台windows上管理多个公匙">一台windows上管理多个公匙</a></li>
    <li><a href="#更多">更多</a></li>
  </ul>
</nav></div>
  

  
    <div>
      
    </div>
  

        </aside>
      </div>

      <div id="footer" class="pt-2 pb-3 bg-white text-center">
        

  <span class="text-small text-gray">
    ©QYF Just for record 2018-2021 &middot; 

    Powered by the
    <a href="https://github.com/qqhann/hugo-primer" class="link-gray-dark">Hugo-Primer</a> theme for
    <a href="https://gohugo.io" class="link-gray-dark">Hugo</a>.
  </span>


      </div>
    </div>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });</script>
    
  </body>
</html>
